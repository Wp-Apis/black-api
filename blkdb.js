bla = process.cwd()
__path = process.cwd()

const PORT = process.env.PORT || 3000

const tiktokapidl = require("@tobyg74/tiktok-api-dl")
const caliphapi = require("caliph-api");
const { xvideoss, xvideosdl, xnxxs, xnxxdl, openai, stalkig, aio, spotify, spotifydl, facebook } = require('betabotz-tools')
const { PornHub } = require('pornhub.js')
const { NSFW } = require("nsfwhub")
const colors = require("colors");
const cfonts = require('cfonts');
const moment = require('moment-timezone');
const Canvasfy = require("canvafy")
const JXR = require("jxr-canvas");
const canvacard = require("canvacard")
const { musicCard, RankCard } = require("musicard-bun");
const { Card } = require("welcomify")
const ffmpeg = require('fluent-ffmpeg');
const uuid = require('uuid').v4
const fs = require('fs')
const hx = require('hxz-api');
const axios = require('axios')
const zrapi = require('zrapi')
const jpeg = require('jpeg-js')
const { GOOGLE_IMG_SCRAP , GOOGLE_QUERY } = require('google-img-scrap');
const { superimg } = require("./base de dados/superimg.js")
const yt = require("@ernestoyoofi/yt.loader-to")
const yts = require('yt-search')
const translate = require('translate-google-api')
const multer = require('multer')
const express = require('express')
const request = require('request');
const cheerio = require('cheerio');
const fetch = require('node-fetch')
const FormData = require('form-data')
const lyricsFinder2 = require('lyrics-finder');
const uber = require('uberduck-api')
var { igstory} = require('./base de dados/scrape.js');
const getInfo = require("./base de dados/opsanime.js");
const icms = require('./base de dados/icms.js')
const { GDriveDl, mediafiredl__ } = require(bla+'/base de dados/download.js');
const { Youtube } = require('ytdownloader.js')
var canvasx = require('discord-canvas')
var { fromBuffer } = require('file-type')
const BrainlySearch = require('./base de dados/brainly.js')
const { PlayLinkMP4_1 } = require('./base de dados/youtube2.js')
const { instagramStoryUser, igProfileStalk, unsplashSearch } = require('./base de dados/get.js')
const { fetchJson } = require('./base de dados/myfunc')
const { audioMeme, yt2mate, yt1s, savef, get } = require("./base de dados/sociais-2.js")
const isUrl = require("is-url")
var gerarnick = require('./base de dados/gerarnick.js')
var { mediafireDl } = require('./base de dados/mediafire.js');
const { fetchTwitterMedia } = require('./base de dados/twtdl.js')
var buffer = require('./base de dados/upload.js')
var exec = require('child_process').exec;
var { Maker } = require('imagemaker.js')
var TikTokScraper = require('tiktok-scraper');
var download = require('@phaticusthiccy/open-apis')
const { shortText } = require("limit-text-js")
const CEP = require('cep-address-finder')
const scraper = require('./base de dados/MULTI_IMDb.js')
const { dafontDownload, dafontSearch, xvideosPorno, pensador } = require("./base de dados/@api.js")
const { rastrearEncomendas } = require("./base de dados/rastreamento.js")
const { EmojiAPI } = require("emoji-api");
const emoji = new EmojiAPI();
var thiccysapi = require('textmaker-thiccy');
var { pinterest } = require('./base de dados/funÃ§Ãµes.js')
const { BrasileirÃ£oFutebol, getNoticiasEsporte } = require("./base de dados/futebol.js")
const { download_Url } = require("./base de dados/function.js");
const mintake = require(bla + '/base de dados/modules/mintake');
const mumaker = require(bla + '/base de dados/modules/mumaker');
const { youtubedl, youtubedlv2 } = require(bla + "/base de dados/modules/scraper-sosmed")
const { PlayLinkMP3, PlayLinkMP4, PlayAudio, PlayVideo, ytSearch2 } = require("./base de dados/youtubev1.js");
const { tikmate, tiklydown } = require("./base de dados/tiktok.js")
var wiki = require("@dada513/wikipedia-search")
const ytdl = require("ytdl-core")
const tesseract = require("node-tesseract-ocr");
const NASA = require('@killovsky/nasa');
var trans = require('@vitalets/google-translate-api')
const SANIME = require('selfietoanime');
var Deezer = require("deezer-web-api");
var DeezerClient = new Deezer();
const {savefrom} = require('./base de dados/savefrom.js')
const Pokemon = require('pokemon.js');
const cors = require('cors')
const matheusapiblk = require("./base de dados/listdl.js")
const testing = require("./base de dados/listdl2.js")
const BitlyClient = require('bitly').BitlyClient
const TinyURL = require('tinyurl');
const unfetch = require('isomorphic-unfetch');
const { wikimedia } = require("./base de dados/scraper/wikimedia.js")
const { wall } = require("./base de dados/scraper/scraper.js")
var { color } = require('./base de dados/color.js')
const { Mp3Download, Mp4Download } = require("./base de dados/y2mate.js")
var { ytMp3, ytMp4, ytPlay, ytPlayMp4, ytSearch, ytVideosSearch } = require('./base de dados/yt.js')
const { fbdown } = require("./base de dados/facebook.js")
const { saveig, saveig_reels, getmyfb } = require("./base de dados/sociais.js");
const { ytDonlodMp3_3, ytDonlodMp4_3, ytPlayMp3_3, ytPlayMp4_3, ytSearch_3 } = require("./base de dados/youtubev3");
//const { facebook } = require('./base de dados/downloader.js')
const { gis } = require('./base de dados/gimage.js')
var { ytMp3_2, ytMp4_2, ytPlay_2 } = require('./base de dados/youtubev2.js')
var { nerding, gpwhatsapp, apkmody, pornhubsrc, uptodown, igstalk, soundl, playstore, manga, anime, hentaistube, pornogratis, filme, wattpad } = require('./base de dados/scraper2.js')
var { pensadorSearch, wallpaper2 } = require('./base de dados/scrapper-api.js')
var { tiktok2, FacebookMp4 } = require('./base de dados/downloader.js')
var { PlayStoreSearch, MercadoLivreSearch, AmazonSearch, AmericanasSearch, SubmarinoSearch, Horoscopo, Dicionario } = require('./base de dados/scraper-2/pesquisas.js');
var { pinterestVideoV2 } = require('./base de dados/pinterest.js');
var { kwai } = require('./base de dados/kwai.js')
var { InArtificial, CorretorOpenAi } = require('./base de dados/scrapper-vip.js');
var { getVideosPlaylist } = require('./base de dados/playlist.js');
const scrapper = require("./base de dados/scrapper.js")
var { G1, Poder360, JovemPan, Uol, CNNBrasil, Estadao } = require('./base de dados/scraper/noticias.js')
const path = require("path");
const { dirname } = require('path');
var __dirname = dirname(__filename);
var { memesDroid } = require('./base de dados/scraper/aleacrapper.js')
var { iFunny } = require("./base de dados/ifunny.js")
var { ringtone } = require('./base de dados/scraper/ringtone.js')
var { lirik } = require('./base de dados/sab_scraper.js')
const { AnimeWallpaper } = require("anime-wallpaper");
const BuscaWallpaper = new AnimeWallpaper();
const { snapsave } = require("@bochilteam/scraper")
var { facebookDownloader, instaVideoV1 } = require('./base de dados/scraper/downloaders.js')
var { LetradaMusica } = require('./base de dados/letraMusic.js')
const Instagram = require('./base de dados/igdl.js')
const { musicard, comunismo, bolsonaro, bnw, blurr, affect, beautiful, circle, del, gay, lgbt, invert, facepalm, dither, jail, magik, pixelate, rip, sepia, rotate, trash, wanted, wasted, bobross, mms, karaba } = require('./base de dados/canvas.js')
const { happymodr } = require('./base de dados/happymod.js')
const { wikiSearch } = require('./base de dados/wikipediaBr.js');
const { aiovideodl, umma, ytPlay_3 } = require('./base de dados/scraper-2.js');
const { randomGrupos } = require('./base de dados/groups-random.js');
const Image = require('./base de dados/logos/start.js')

async function getBuffer(url) {
he = await fetch(url).then(c => c.buffer())
 return he
}
async function Kibar(url) {
he = await fetch(url).then(c => c.json())
 return he
}

const getRandom = (ext) => {
return `${Math.floor(Math.random() * 10000)}${ext}`;
};

async function getBuffer(url) {
he = await fetch(url)
.then(c => c.buffer())
return he
}

const allReplace = (frase, txt, rp) => {
  caixa = [frase]
  for(i = 0; i < 1000; i++) {
    caixa.push(caixa[i].replace(txt, rp))
  }
  return caixa[caixa.length - 1]
}

const blacksite = `https://blackmd.online`

//-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-\\
// ============[ APIKEYS ]============ \\
const senhapv = "ryuudelas"
var key = JSON.parse(fs.readFileSync("./database/apikeys.json"));
const usuarios = JSON.parse(fs.readFileSync("./database/usuarios.json"));
const tinder = JSON.parse(fs.readFileSync("./database/tinder.json"));

async function RegisKey(apikey, req) {
var i4 = key.map(i => i?.apikey)?.indexOf(apikey)
if(i4 >= 0) {
key[i4].request -= 1;
fs.writeFileSync("./database/apikeys.json", JSON.stringify(key, null, 2));
var IP = req.headers['x-real-ip'] || req.connection.remoteAddress || 0;
var i3 = usuarios.map(i => i.key).indexOf(apikey);
if(i3 < 0 && !usuarios.map(i => i.IP).includes(IP?.split(":")[3])){
usuarios.push({key: apikey, IP: [IP?.split(":")[3]]})
fs.writeFileSync("./database/usuarios.json", JSON.stringify(usuarios, null, 2));
} else if(i3 >= 0 && !usuarios[i3]?.IP.includes(IP?.split(":")[3])) {
usuarios[i3].IP.push(IP?.split(":")[3])
fs.writeFileSync("./database/usuarios.json", JSON.stringify(usuarios, null, 2));
}}}

//-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-\\

// ===[INÃCIO - KEYS ENCURTAR LINK]===== \\
apicuttly = ['4786cc6a0f19de9c67ea6a4282c494323c932','2038c1a7754b408aa8f9055282638c00e668e','89d73b3a07209177d0251e30d49d66bd669ac','e841147455d0fdfbf50f74aefe63b6728adc0','27f3aa3f45cb4460bcbac69b782ca470a4570','31a8df09d5a9d8d009790df0b5642e3d76919','09b4e764ff07b10eac1682e71aaf95a78f358','75fe576ce040b619176af22f5a718b2f574f5','e24ee36f9c1519c0a779667a5182a31fb7ccf','903869065d29e23455ddca922071f4bbeb133']
apibitly = ['6cfc18e9bfa554714fadc10a1f6aff7555642348','2243940c230ad0d748059aee58ddf126b65fd8e7','c71b6658a1d271ddaf2a5077de3dcb9d67f68025','cddbceccdc2f1c9d11e4cdd0d2b1d1078e447c43','7915c671fbd90eca96310e5c9442d761225a1080','e5dee46eb2d69fc9f4b0057266226a52a3555356','f09ab8db9cf778b37a1cf8bc406eee5063816dec','964080579f959c0cc3226b4b2053cd6520bb60ad','a4f429289bf8bf6291be4b1661df57dde5066525','3d48e2601f25800f375ba388c30266aad54544ae','4854cb9fbad67724a2ef9c27a9d1a4e9ded62faa','d375cf1fafb3dc17e711870524ef4589995c4f69','43f58e789d57247b2cf285d7d24ab755ba383a28','971f6c6c2efe6cb5d278b4164acef11c5f21b637','ae128b3094c96bf5fd1a349e7ac03113e21d82c9','e65f2948f584ffd4c568bf248705eee2714abdd2','08425cf957368db9136484145aa6771e1171e232','dc4bec42a64749b0f23f1a8f525a69184227e301','0f9eb729a7a08ff5e73fe1860c6dc587cc523035','037c5017712c8f5f154ebbe6f91db1f82793c375']

// ===[FIM - KEYS ENCURTAR LINK]===== \\

const headers = {
'accept': '*/*',
'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/101.0.4951.64 Safari/537.36 Edg/101.0.1210.53',
'Accept-Language': 'en-US,en;q=0.9,it;q=0.8,es;q=0.7',
'referer': 'https://www.google.com/',
'cookie': 'DSID=AAO-7r4OSkS76zbHUkiOpnI0kk-X19BLDFF53G8gbnd21VZV2iehu-w_2v14cxvRvrkd_NjIdBWX7wUiQ66f-D8kOkTKD1BhLVlqrFAaqDP3LodRK2I0NfrObmhV9HsedGE7-mQeJpwJifSxdchqf524IMh9piBflGqP0Lg0_xjGmLKEQ0F4Na6THgC06VhtUG5infEdqMQ9otlJENe3PmOQTC_UeTH5DnENYwWC8KXs-M4fWmDADmG414V0_X0TfjrYu01nDH2Dcf3TIOFbRDb993g8nOCswLMi92LwjoqhYnFdf1jzgK0'};

const router = express.Router();

var upload = multer()

var app = express()
 
app.use(cors())
app.set("json spaces",2)
app.use(express.static("public"))

function delFile(file) {
try { fs.unlinkSync(file) } catch (error) {}
}

const { UltimateTextToImage, registerFont } = require("ultimate-text-to-image");

const ffmpegPath = require('@ffmpeg-installer/ffmpeg').path;

ffmpeg.setFfmpegPath(ffmpegPath);

registerFont((__dirname + '/base de dados/fontes/NotoEmoji.ttf'), { family: 'Noto Emoji' });
registerFont(__dirname + '/base de dados/fontes/NotoSansMono.ttf', { family: 'Noto Sans Mono' });

let randomName = (ext) => uuid().split('-')[0] + (ext ? ext : '');

var cores = ['red','lime','yellow','magenta','cyan'];

async function ttp(text, color = '#ffffff', name = randomName('.png')) {
new UltimateTextToImage(text, {
width: 500,
height: 500,
fontFamily: "Noto Emoji, Noto Sans Mono",
fontColor: color,
fontSize: 300,
minFontSize: 10,
lineHeight: 50,
autoWrapLineHeightMultiplier: 1.2,
margin: 15,
//marginBottom: 40,
align: "center",
valign: "middle",
}).render().toFile(`./assets/attp-logs/${name}`);
return `./assets/attp-logs/${name}`;
}

async function attp(text) {
let nome = randomName('');
let lista = [
ttp(text, '#ff0000', `${nome}0.png`),
ttp(text, '#ffa600', `${nome}1.png`),
ttp(text, '#ffee00', `${nome}2.png`),
ttp(text, '#2bff00', `${nome}3.png`),
ttp(text, '#00ffea', `${nome}4.png`),
ttp(text, '#3700ff', `${nome}5.png`),
ttp(text, '#ff00ea', `${nome}6.png`),
];

return new Promise(function (resolve, reject) {
// gerar webp
ffmpeg().addInput((`./assets/attp-logs/${nome}`+"%d.png"))
.addOutputOptions(['-vcodec', 'libwebp', '-vf','scale=500:500:force_original_aspect_ratio=decrease,setsar=1, pad=500:500:-1:-1:color=white@0.0, split [a][b]; [a] palettegen=reserve_transparent=on:transparency_color=ffffff [p]; [b][p] paletteuse', '-loop', '50', '-preset', 'default'])
//.outputFPS(15)
.toFormat('webp')
.on('end', () => {
for (let img = 0; img < lista.length; img++) {
delFile("*png");
}
resolve('./assets/attp-logs/'+nome+'.webp')}).on('error', (err) => {
for (let img = 0; img < lista.length; img++) {
delFile("*webp");
}
reject(('erro ffmpeg ' + err));
}).save(('./assets/attp-logs/'+nome+'.webp'));
});
}

////PAGINA INICIAL Q IRA REDIRECIONAR PRA /DOC
 
app.get("/", (req,res,next) => {
console.log("Beep");
res.end("Boop");
})
app.use(router);

app.get('/admin',(req, res) => {
res.sendFile(path.join(__dirname, "./public/", "admin.html"))})

app.get('/docs' ,(req, res) => {
res.sendFile(path.join(__dirname, "./public/", "docs.html"))})

app.get('/store',(req, res) => {
res.sendFile(path.join(__dirname, "./public/", "store.html"))})

app.get('/api/lerfoto',(req, res) => {
var { url } = req.query
ReadText(url).then(text => {
  console.log(text);
}).catch(err => {
  console.log(err);
})
})

app.get('/dono/addkey',(req, res) => {
a = req.query.a
if(!a.includes("&")) return res.json({message: "Faltando o and"})
var [apikey, rq, senha] = a.split("&")
if(!apikey) return res.json({message: "CadÃª a key?"})
if(!rq) return res.json({message: "KD a quant. de request?"})
var senhaofc = senhapv
if(senha != senhaofc) return res.json({message: "[â—] senha invÃ¡lida ou inexistente âŒ"})
if(key.map(i => i.apikey).includes(apikey)) {
var i2 = key.map(i => i.apikey).indexOf(apikey)
key[i2].request += Number(rq)
fs.writeFileSync("./database/apikeys.json", JSON.stringify(key))
return res.json({message: `âœ”ï¸ ${rq} foram adc a apikey ${apikey} com sucesso...`})
} else {
key.push({apikey: apikey, request: Number(rq)})
fs.writeFileSync("./database/apikeys.json", JSON.stringify(key))
return res.json({message: `âœ”ï¸ Apikey ${apikey} registrada com sucesso...`})
}
})

app.get('/dono/rmkey',(req, res) => {
a = req.query.a
if(!a.includes("&")) return res.json({message: "Faltando o and"})
var [apikey, senha] = a.split("&")
var senhaofc = senhapv
if(senha != senhaofc) return res.json({message: "[â—] senha invÃ¡lida ou inexistente âŒ"})
if(!apikey) return res.json({message: "CadÃª a key?"})
if(!key.map(i => i.apikey).includes(apikey)) {
return res.json({message: "[â—] apikey nÃ£o encontrada ou inexistente âŒ"})
} else {
var i2 = key.map(i => i.apikey).indexOf(apikey)
key.splice(i2, 1)
fs.writeFileSync("./database/apikeys.json", JSON.stringify(key))
return res.json({message: `âœ–ï¸ Apikey ${apikey} deletada com sucesso...`})
}
})

app.get('/dono/adc-key',(req, res) => {
var { apikey, request, senha } = req.query
if(!apikey) return res.json({message: "VocÃª esqueceu de preencher o nome que vocÃª deseja na apikey."})
if(!request) return res.json({message: "Qual Ã© a quantidade de request que vocÃª deseja por Ã  apikey?"})
if(!senha) return res.json({message: "A senha nÃ£o foi preenchida, por seguranÃ§a insira a senha que vocÃª criou."})
var senhaofc = senhapv
if(senha != senhaofc) return res.json({message: "[â—] senha invÃ¡lida ou inexistente âŒ"})
if(key.map(i => i.apikey).includes(apikey)) {
var i2 = key.map(i => i.apikey).indexOf(apikey)
key[i2].request += Number(request)
fs.writeFileSync("./database/apikeys.json", JSON.stringify(key))
return res.json({message: `âœ”ï¸ ${request} requests foram adc a apikey ${apikey} com sucesso...`})
} else {
key.push({apikey: apikey, request: Number(request)})
fs.writeFileSync("./database/apikeys.json", JSON.stringify(key))
return res.json({message: `âœ”ï¸ _Apikey registrada com sucesso â†´_
ğŸ”‘ *Key:* ${apikey}
ğŸ’¾ *Requests:* ${request}`})
}
})

app.get('/dono/del-key',(req, res) => {
var { apikey, senha } = req.query
if(!apikey) return res.json({message: "VocÃª esqueceu de preencher o nome que vocÃª deseja na apikey."})
if(!senha) return res.json({message: "A senha nÃ£o foi preenchida, por seguranÃ§a insira a senha que vocÃª criou."})
var senhaofc = senhapv
if(senha != senhaofc) return res.json({message: "[â—] senha invÃ¡lida ou inexistente âŒ"})
if(!apikey) return res.json({message: "Qual Ã© a apikey que vocÃª deseja remover?"})
if(!key.map(i => i.apikey).includes(apikey)) {
return res.json({message: "[â—] apikey nÃ£o encontrada ou inexistente âŒ"})
} else {
var i2 = key.map(i => i.apikey).indexOf(apikey)
key.splice(i2, 1)
fs.writeFileSync("./database/apikeys.json", JSON.stringify(key))
return res.json({message: `âœ–ï¸ Apikey ${apikey} deletada com sucesso...`})
}
})

app.get('/dono/listkey', async (req, res, next) => {
var senha = req.query.senha
if(!senha) return res.json({message: "A senha nÃ£o foi preenchida, por seguranÃ§a insira a senha que vocÃª criou."})
var senhaofc = senhapv
if(senha != senhaofc) return res.json({message: "A senha digitada estÃ¡ invÃ¡lida, verifique por favor."})
listApikeys = JSON.parse(fs.readFileSync(bla +'/database/apikeys.json').toString())
res.json(listApikeys) 
})

app.get('/dono/iplist', async (req, res, next) => {
var senha = req.query.senha
if(!senha) return res.json({message: "A senha nÃ£o foi preenchida, por seguranÃ§a insira a senha que vocÃª criou."})
var senhaofc = senhapv
if(senha != senhaofc) return res.json({message: "A senha digitada estÃ¡ invÃ¡lida, verifique por favor."})
listUsersIP = JSON.parse(fs.readFileSync(bla +'/database/usuarios.json').toString())
res.json(listUsersIP) 
})

app.get('/api/keyerrada',(req, res) => {
apikey = req.query.apikey;
var ITC = key.map(i => i?.apikey)?.indexOf(apikey);
if(ITC < 0) {
return res.json({message:'Apikey invÃ¡lida ou requests esgotados!'})
} else {
return res.json({status: true, message: "Key ativa âœ…", limite_de_request: key[ITC]?.request, consulta: key[ITC]?.consulta, horarios: key[ITC]?.horarios})
}
})

app.get('/tinder/login',(req, res) => {
  var { usu, rg, apikey } = req.query
  if(!apikey) return res.json({message: "Faltando paramento apikey"})
  if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
  if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
  if(!usu) return res.json({message: "Faltando paramento usuÃ¡rio"})
  if(!JSON.stringify(tinder).includes(usu)) {
    tinder.push({id: usu, nome: 0, idade: 0, gene: 0, sexualidade: 0, filtro: 0, bio: 0, foto: 0, dataRG: 0, horaRG: 0})
    fs.writeFileSync("./database/tinder.json", JSON.stringify(tinder, null, 2))
  }
  AB = tinder.map(i => i.id).indexOf(usu)
  if(tinder[AB].nome != 0 && tinder[AB].idade != 0 && tinder[AB].gene != 0 && tinder[AB].filtro != 0 && tinder[AB].bio != 0 && tinder[AB].foto != 0) return res.json({message: "VocÃª jÃ¡ estÃ¡ registrado... Use #p#tinder"})
  if(!rg) {
    if(tinder[AB].nome == 0) return res.json({semft: false, message: "Retorne apÃ³s o comando o seu nome para o registro"})
    if(tinder[AB].idade == 0) return res.json({semft: false, message: "Retorne apÃ³s o comando a sua idade para o registro"})
    if(tinder[AB].gene == 0) return res.json({semft: false, message: "Retorne apÃ³s o comando o seu gÃªnero para o registro"})
    if(tinder[AB].sexualidade == 0) return res.json({semft: false, message: "Retorne apÃ³s o comando a sua sexualidade para o registro"})
    if(tinder[AB].filtro == 0) return res.json({semft: false, message: "Retorne apÃ³s o comando o filtro de pesquisa para o registro"})
    if(tinder[AB].bio == 0) return res.json({semft: false, message: "Retorne apÃ³s o comando a sua bio para o registro"})
    if(tinder[AB].foto == 0) return res.json({semft: true, message: "Marque uma foto para completar seu registro"})
  }
  if(!apikey) return res.json({message: "Faltando paramento apikey"})
  if(tinder[AB].nome == 0) {
    tinder[AB].nome = rg
    fs.writeFileSync("./database/tinder.json", JSON.stringify(tinder, null, 2))
    return res.json({semft: false, message: "Nome registrado com sucesso... Use o comando novamente, mas dessa vez, coloque a sua idade, ex:\n#pc# 18"})
  }
  if(tinder[AB].idade == 0) {
    if(!Number(rg)) return res.json({message: "Sua idade sÃ³ pode conter nÃºmeros"})
    if(Number(rg) < 12) return res.json({message: "Precisa ter no mÃ­nimo 12 anos para usar o tinder..."})
    if(Number(rg) > 50) return res.json({message: "UsuÃ¡rios com mais de 50 anos nÃ£o serÃ£o aceitos..."})
    if(rg.includes(".")) return res.json({message: "Tua idade tem nÃºmero decimal Ã©? Kkkk"})
    tinder[AB].idade = rg
    fs.writeFileSync("./database/tinder.json", JSON.stringify(tinder, null, 2))
    return res.json({semft: false, message: "Idade registrada com sucesso... Use o comando novamente, mas dessa vez, coloque seu gÃªnero para o perfil, ex:\n#pc# \"masculino\" ou \"feminino\" ou \"nÃ£o declarar\" (sem as aspas)"})
  }
  if(tinder[AB].gene == 0) {
    if(rg.toLowerCase() != "masculino" && rg.toLowerCase() != "feminino" && rg.toLowerCase().replace("Ã£", "a") != "nao declarar") return res.json({semft: false, message: "GÃªnero invÃ¡lido... Use apenas \"masculino\" ou \"feminino\" ou \"nÃ£o declarar\" (sem as aspas)"})
    tinder[AB].gene = rg
    fs.writeFileSync("./database/tinder.json", JSON.stringify(tinder, null, 2))
    return res.json({semft: false, message: "GÃªnero registrado com sucesso... Use o comando novamente, mas dessa vez, coloque a sua sexualidade, ou seja, como vocÃª se identifica"})
  }
  if(tinder[AB].sexualidade == 0) {
    tinder[AB].sexualidade = rg
    fs.writeFileSync("./database/tinder.json", JSON.stringify(tinder, null, 2))
    return res.json({semft: false, message: "Sexualidade registrada com sucesso... Use o comando novamente, mas dessa vez, coloque um filtro para busca, usando 1 para homens, 2 para mulheres e 3 para todos, ex:\n#pc# 3"})
  }
  if(tinder[AB].filtro == 0) {
    if(Number(rg) < 1 && Number(rg) > 3) return res.json({semft: false, message: "Registro de busca invÃ¡lido... Use 1 para homens, 2 para mulheres e 3 para todos, ex:\n#pc# 3"})
    tinder[AB].filtro = Number(rg)
    fs.writeFileSync("./database/tinder.json", JSON.stringify(tinder, null, 2))
    return res.json({semft: false, message: "Filtro registrado com sucesso... Use o comando novamente, mas dessa vez, coloque uma bio pro seu perfil, ex:\n#pc# apenas vivendo"})
  }
  if(tinder[AB].bio == 0) {
    tinder[AB].bio = rg
    fs.writeFileSync("./database/tinder.json", JSON.stringify(tinder, null, 2))
    return res.json({semft: false, message: "Bio registrada com sucesso... Por Ãºltimo, marque uma imagem com o comando #pc# para ser sua foto de perfil"})
  }
  if(tinder[AB].foto == 0) {
    sla = `${moment.tz('America/Sao_Paulo').format('HH')} hora${Number(moment.tz('America/Sao_Paulo').format('HH')) !== 1 ? "s" : ""}, ${moment.tz('America/Sao_Paulo').format('mm')} minuto${Number(moment.tz('America/Sao_Paulo').format('mm')) !== 1 ? "s" : ""} e ${moment.tz('America/Sao_Paulo').format('ss')} segundo${Number(moment.tz('America/Sao_Paulo').format('ss')) !== 1 ? "s" : ""}`
    tinder[AB].foto = rg
    tinder[AB].dataRG = moment.tz('America/Sao_Paulo').format('DD/MM/20YY')
    tinder[AB].horaRG = sla
    fs.writeFileSync("./database/tinder.json", JSON.stringify(tinder, null, 2))
    RegisKey(apikey, req);
    return res.json({message: `Registro finalizado com sucesso... Bem vind${tinder[AB].gene == "masculino" ? 'o' : tinder[AB].gene == "feminino" ? 'a' : 'x'} ao tinder ${tinder[AB].nome} â¤ï¸â€ğŸ”¥

Use #p#tinder para acessar os usuÃ¡rios e #p#sairtinder caso queira meter o pÃ©`})
  }
})

app.get('/tinder/find', async (req, res) => {
usu = req.query.usu
if(tinder.length <= 0) return res.json({message: "Nenhum usuÃ¡rio registrado..."})
if(!usu) return res.json({message: "Faltando o parÃ¢metro usuÃ¡rio"})
apikey = req.query.apikey
if(!apikey) return res.json({message: "Faltando o parÃ¢metro apikey"})
if(!key.map(i => i.apikey)?.includes(apikey)) return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
AB = tinder.map(i => i.id).indexOf(usu)
if(!JSON.stringify(tinder).includes(usu)) return res.json({message: "VocÃª nÃ£o estÃ¡ registrado no tinder... Use #p#rgtinder para comeÃ§ar ğŸ˜‰"})
if(tinder[AB].nome == 0 || tinder[AB].idade == 0 || tinder[AB].gene == 0 || tinder[AB].sexualidade == 0 || tinder[AB].filtro == 0 || tinder[AB].bio == 0 || tinder[AB].foto == 0) return res.json({nome: tinder[AB].nome, idade: tinder[AB].idade, gene: tinder[AB].gene, sexualidade: tinder[AB].sexualidade, filtro: tinder[AB].filtro, bio: tinder[AB].bio, nmr: tinder[AB].id.split('@')[0], foto: tinder[AB].foto, message: "Algum campo do registro nÃ£o foi preenchido... Use o comando #p#rgtinder para saber o que falta!"})
caixa = []
for(i = 0; i < tinder.length; i++) {
  //filtro de busca por homens
  if(tinder[AB].filtro == 1 && tinder[i].gene == "masculino" && tinder[i].sexualidade != 0 && tinder[i].filtro != 0 && tinder[AB].bio != 0 && tinder[i].foto != 0) caixa.push({nome: tinder[i].nome, idade: tinder[i].idade, gene: tinder[i].gene, sexualidade: tinder[i].sexualidade, filtro: tinder[i].filtro, bio: tinder[i].bio, nmr: tinder[i].id.split('@')[0], foto: tinder[i].foto})
  //filtro de busca por mulheres
  if(tinder[AB].filtro == 2 && tinder[i].gene == "feminino" && tinder[i].sexualidade != 0 && tinder[i].filtro != 0 && tinder[AB].bio != 0 && tinder[i].foto != 0) caixa.push({nome: tinder[i].nome, idade: tinder[i].idade, gene: tinder[i].gene, sexualidade: tinder[i].sexualidade, filtro: tinder[i].filtro, bio: tinder[i].bio, nmr: tinder[i].id.split('@')[0], foto: tinder[i].foto})
  //filtro de busca sem preferÃªncia
  if(tinder[AB].filtro == 3 && tinder[i].nome != 0 && tinder[i].idade != 0 && tinder[i].gene != 0 && tinder[i].sexualidade != 0 && tinder[i].filtro != 0 && tinder[i].bio != 0 && tinder[i].foto != 0) caixa.push({nome: tinder[i].nome, idade: tinder[i].idade, gene: tinder[i].gene, sexualidade: tinder[i].sexualidade, filtro: tinder[i].filtro, bio: tinder[i].bio, nmr: tinder[i].id.split('@')[0], foto: tinder[i].foto})
}
if(caixa.length <= 0) return res.json({message: "Nenhum usuÃ¡rio foi encontrado com esse filtro de pesquisa... Podes trocar o filtro no comando #p#setfiltro"})
BC = Math.floor(Math.random()*caixa.length)
res.json({criador: "@m4thxyz_", dados: [{id: BC+1, total: caixa.length, nome: caixa[BC].nome, idade: caixa[BC].idade, gene: caixa[BC].gene, sexualidade: caixa[BC].sexualidade, bio: caixa[BC].bio, nmr: caixa[BC].nmr, foto: caixa[BC].foto}]})
})

app.get('/tinder/config', async (req, res) => {
var { usu, mod, q, apikey } = req.query
if(!usu) return res.json({message: "Faltando o parÃ¢metro usuÃ¡rio"})
if(!mod) return res.json({message: "Faltando o parÃ¢metro mod"})
if(!q) {
  if(mod == "tindernome") return res.json({message: "Retorne apÃ³s o comando o novo nome para atualizar o perfil"})
  if(mod == "tinderidade") return res.json({message: "Retorne apÃ³s o comando a nova idade para atualizar o perfil"})
  if(mod == "tinderbio") return res.json({message: "Retorne apÃ³s o comando a nova bio para atualizar o perfil"})
  if(mod == "tinderfoto") return res.json({message: "Marque com o comando uma foto para atualizar seu perfil"})
  if(mod == "setgene") return res.json({message: "Retorne apÃ³s o comando o seu gÃªnero para atualizar o perfil... Use \"masculino\", \"feminino\" ou \"nÃ£o declarar\""})
  if(mod == "setsex") return res.json({message: "Retorne apÃ³s o comando a sua sexualidade para atualizar o perfil..."})
  if(mod == "setfiltro") return res.json({message: "Retorne apÃ³s o comando o nÃºmero correspondente ao filtro de pesquisa do seu tinder... 1 para homens, 2 para mulheres e 3 para todos"})
  }
if(!apikey) return res.json({message: "Faltando o parÃ¢metro apikey"})
if(!key.map(i => i.apikey)?.includes(apikey)) return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
if(!JSON.stringify(tinder).includes(usu)) return res.json({message: "VocÃª nÃ£o estÃ¡ registrado no tinder... Use #pc#rgtinder para comeÃ§ar ğŸ˜‰"})
AB = tinder.map(i => i.id).indexOf(usu)
if(tinder[AB].nome == 0 || tinder[AB].idade == 0 || tinder[AB].gene == 0 || tinder[AB].sexualidade == 0 || tinder[AB].filtro == 0 || tinder[AB].bio == 0 || tinder[AB].foto == 0) return res.json({nome: tinder[AB].nome, idade: tinder[AB].idade, gene: tinder[AB].gene, sexualidade: tinder[AB].sexualidade, filtro: tinder[AB].filtro, bio: tinder[AB].bio, nmr: tinder[AB].id.split('@')[0], foto: tinder[AB].foto, message: "Algum campo do registro nÃ£o foi preenchido... Use o comando #p#rgtinder para saber o que falta!"})
RegisKey(apikey, req);
  if(mod == "tindernome") {
    tinder[AB].nome = q
    fs.writeFileSync("./database/tinder.json", JSON.stringify(tinder, null, 2))
    return res.json({message: "Nome atualizado com sucesso âœ…"})
  }
  if(mod == "tinderidade") {
    if(!Number(q)) return res.json({message: "Sua idade sÃ³ pode conter nÃºmeros"})
    if(Number(q) < 12) return res.json({message: "Precisa ter no mÃ­nimo 12 anos para usar o tinder..."})
    if(Number(q) > 70) return res.json({message: "UsuÃ¡rios com mais de 70 anos nÃ£o serÃ£o aceitos..."})
    if(q.includes(".")) return res.json({message: "Tua idade tem nÃºmero decimal Ã©? Kkkk"})
    tinder[AB].idade = q
    fs.writeFileSync("./database/tinder.json", JSON.stringify(tinder, null, 2))
    return res.json({semft: false, message: "Idade atualizada com sucesso âœ…"})
  }
  if(mod == "setgene") {
    if(q.toLowerCase() != "masculino" && q.toLowerCase() != "feminino" && q.toLowerCase().replace("Ã£", "a") != "nao declarar") return res.json({message: "GÃªnero invÃ¡lido... Use apenas \"masculino\" ou \"feminino\" ou \"nÃ£o declarar\" (sem as aspas)"})
    tinder[AB].gene = q
    fs.writeFileSync("./database/tinder.json", JSON.stringify(tinder, null, 2))
    return res.json({message: "GÃªnero atualizado com sucesso âœ…"})
  }
  if(mod == "setsex") {
    tinder[AB].sexualidade = q
    fs.writeFileSync("./database/tinder.json", JSON.stringify(tinder, null, 2))
    return res.json({message: "GÃªnero atualizado com sucesso âœ…"})
  }
  if(mod == "setfiltro") {
    if(Number(q) < 1 && Number(q) > 3) return res.json({semft: false, message: "Registro de busca invÃ¡lido... Use 1 para homens, 2 para mulheres e 3 para todos, ex:\n#pc# 3"})
    tinder[AB].filtro = Number(q)
    fs.writeFileSync("./database/tinder.json", JSON.stringify(tinder, null, 2))
    return res.json({message: `Filtro de pesquisa atualizado com sucesso... Agora buscarei ${Number(q) === 3 ? `por todos os usuÃ¡rios ğŸ˜‰` : `apenas por ${Number(q) === 1 ? "homens ğŸ«¢" : "mulheres ğŸ˜"}`}`})
  }
  if(mod == "tinderbio") {
    tinder[AB].bio = q
    fs.writeFileSync("./database/tinder.json", JSON.stringify(tinder, null, 2))
    return res.json({message: "Bio atualizada com sucesso âœ…"})
  }
  if(mod == "tinderfoto") {
    tinder[AB].foto = q
    fs.writeFileSync("./database/tinder.json", JSON.stringify(tinder, null, 2))
    return res.json({message: "Foto de perfil atualizada com sucesso âœ…"})
  }
})

app.get('/tinder/perfil', async (req, res) => {
var { usu, apikey } = req.query
if(!usu) return res.json({message: "Faltando o parÃ¢metro usuÃ¡rio"})
if(!apikey) return res.json({message: "Faltando o parÃ¢metro apikey"})
if(!key.map(i => i.apikey)?.includes(apikey)) return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
if(!JSON.stringify(tinder).includes(usu)) return res.json({message: "ID do usuÃ¡rio nÃ£o encontrado ou inexistente..."})
AB = tinder.map(i => i.id).indexOf(usu)
if(tinder[AB].nome == 0 || tinder[AB].idade == 0 || tinder[AB].gene == 0 || tinder[AB].sexualidade == 0 || tinder[AB].filtro == 0 || tinder[AB].bio == 0 || tinder[AB].foto == 0) return res.json({nome: tinder[AB].nome, idade: tinder[AB].idade, gene: tinder[AB].gene, sexualidade: tinder[AB].sexualidade, filtro: tinder[AB].filtro, bio: tinder[AB].bio, nmr: tinder[AB].id.split('@')[0], foto: tinder[AB].foto, message: "Algum campo do registro nÃ£o foi preenchido... Use o comando #p#rgtinder para saber o que falta!"})
RegisKey(apikey, req);
return res.json({criador: "@m4thxyz_", dados: [{nome: tinder[AB].nome, idade: tinder[AB].idade, gene: tinder[AB].gene, sexualidade: tinder[AB].sexualidade, filtro: tinder[AB].filtro, bio: tinder[AB].bio, nmr: tinder[AB].id.split('@')[0], foto: tinder[AB].foto, registro: [tinder[AB].dataRG, tinder[AB].horaRG]}]})
})

app.get('/tinder/delete', async (req, res) => {
var { usu, apikey } = req.query
if(!usu) return res.json({message: "Faltando o parÃ¢metro usuÃ¡rio"})
if(!apikey) return res.json({message: "Faltando o parÃ¢metro apikey"})
if(!key.map(i => i.apikey)?.includes(apikey)) return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
if(!JSON.stringify(tinder).includes(usu)) return res.json({message: "ID do usuÃ¡rio nÃ£o encontrado ou inexistente..."})
AB = tinder.map(i => i.id).indexOf(usu)
tinder.splice(AB, 1)
fs.writeFileSync("./database/tinder.json", JSON.stringify(tinder, null, 2))
RegisKey(apikey, req);
return res.json({message: "Seu registro foi deletado com sucesso.. Volte sempre ğŸ˜‰"})
})

app.get('/api/canvas/welcome', async (req, res, next) => {
if(!req.query.titulo) return res.json({ status: 404, error: 'Insira o parametro: titulo'})
if(!req.query.perfil) return res.json({ status: 404, error: 'Insira o parametro: perfil'})
if(!req.query.fundo) return res.json({ status: 404, error: 'Insira o parametro: fundo'})
if(!req.query.desc) return res.json({ status: 404, error: 'Insira o parametro: desc'})
let wewelcomeer = await new Canvasfy.WelcomeLeave()
  .setAvatar(req.query.perfil)
  .setBackground("image", req.query.fundo)
  .setTitle(req.query.titulo)
  .setDescription(req.query.desc)
  .setBorder("#2a2e35")
  .setAvatarBorder("#2a2e35")
  .setOverlayOpacity(0.6)
  .build();
require('fs').writeFileSync(bla + '/assets/Tempo/welkom.png', wewelcomeer, 'base64')
res.sendFile(bla + '/assets/Tempo/welkom.png')
})

app.get('/api/canvas/top', async (req, res, next) => {
  var { message, fundo, foto1, foto2, foto3, foto4, foto5, foto6, foto7, foto8, foto9, foto10, nome1, nome2, nome3, nome4, nome5, nome6, nome7, nome8, nome9, nome10, xp1, xp2, xp3, xp4, xp5, xp6, xp7, xp8, xp9, xp10 } = req.query
  database = [
    {top: 1, avatar: foto1, tag: nome1, score: Number(xp1)},
    {top: 2, avatar: foto2, tag: nome2, score: Number(xp2)},
    {top: 3, avatar: foto3, tag: nome3, score: Number(xp3)},
    {top: 4, avatar: foto4, tag: nome4, score: Number(xp4)},
    {top: 5, avatar: foto5, tag: nome5, score: Number(xp5)},
    {top: 6, avatar: foto6, tag: nome6, score: Number(xp6)},
    {top: 7, avatar: foto7, tag: nome7, score: Number(xp7)},
    {top: 8, avatar: foto8, tag: nome8, score: Number(xp8)},
    {top: 9, avatar: foto9, tag: nome9, score: Number(xp9)},
    {top: 10, avatar: foto10, tag: nome10, score: Number(xp10)}
    ]
  const top10 = await new Canvasfy.Top()
  .setOpacity(0.6)
  .setScoreMessage(message)
  .setabbreviateNumber(true)
  .setBackground("image", fundo)
  .setColors({box: "#212121", username: "#ffffff", score: "#ffffff", firstRank: "#f7c716", secondRank: "#9e9e9e", thirdRank: "#94610f"})
  .setUsersData(database)
  .build();

require('fs').writeFileSync(bla + '/assets/Tempo/welkom.png', top10, 'base64')
res.sendFile(bla + '/assets/Tempo/welkom.png')
})

app.get('/api/canvas/level', async (req, res, next) => {
var { foto, nome, expnow, expall, level, fundo } = req.query
if(!foto) return res.json({message: "Faltando o parÃ¢metro foto"})
if(!nome) return res.json({message: "Faltando o parÃ¢metro nome"})
if(!expnow) return res.json({message: "Faltando o parÃ¢metro XP atual"})
if(!expall) return res.json({message: "Faltando o parÃ¢metro XP total"})
if(!level) return res.json({message: "Faltando o parÃ¢metro level"})
if(!fundo) return res.json({message: "Faltando o parÃ¢metro fundo"})
let rank1 = await new Canvasfy.Rank()
    .setAvatar(foto)
    .setBackground("image", fundo)
    .setUsername(nome)
    .setBorder("#fff")
    .setBarColor("#00ffff")
    .setStatus("online")
    .setLevel(Number(level))
    .setLevelColor({text:"#00ffff",number:"#fff"})
    .setRank(Number(expnow), "XP")
    .setRankColor({text:"#00ffff",number:"#fff"})
    .setCurrentXp(Number(expnow))
    .setRequiredXp(Number(expall))
    .build();

require('fs').writeFileSync(bla + '/assets/Tempo/welkom.png', rank1, 'base64')
res.sendFile(bla + '/assets/Tempo/welkom.png')
})

app.get('/api/canvas/levelup', async (req, res, next) => {
var { foto, nome, lvb, lva, fundo } = req.query
if(!foto) return res.json({message: "Faltando o parÃ¢metro foto"})
if(!nome) return res.json({message: "Faltando o parÃ¢metro nome"})
if(!lvb) return res.json({message: "Faltando o parÃ¢metro level before"})
if(!lva) return res.json({message: "Faltando o parÃ¢metro level after"})
if(!fundo) return res.json({message: "Faltando o parÃ¢metro fundo"})
let lvup = await new Canvasfy.LevelUp()
    .setAvatar(foto)
    .setBackground("image", fundo)
    .setUsername(nome)
    .setBorder("#000000")
    .setAvatarBorder("#00ffff")
    .setOverlayOpacity(0.7)
    .setLevels(Number(lvb), Number(lva))
    .build();

require('fs').writeFileSync(bla + '/assets/Tempo/welkom.png', lvup, 'base64')
res.sendFile(bla + '/assets/Tempo/welkom.png')
})

app.get('/api/canvas/levelup2', async (req, res, next) => {
var { foto, nome, lvb, lva, fundo } = req.query
if(!foto) return res.json({message: "Faltando o parÃ¢metro foto"})
if(!nome) return res.json({message: "Faltando o parÃ¢metro nome"})
if(!lvb) return res.json({message: "Faltando o parÃ¢metro level before"})
if(!lva) return res.json({message: "Faltando o parÃ¢metro level after"})
if(!fundo) return res.json({message: "Faltando o parÃ¢metro fundo"})
let lvup2 = await new Canvasfy.LevelUp()
    .setAvatar(foto)
    .setBackground("image", fundo)
    .setUsername(nome)
    .setBorder("#000000")
    .setAvatarBorder("#ff0000")
    .setOverlayOpacity(0.7)
    .setLevels(Number(lvb), Number(lva))
    .build();

require('fs').writeFileSync(bla + '/assets/Tempo/welkom.png', lvup2, 'base64')
res.sendFile(bla + '/assets/Tempo/welkom.png')
})

app.get('/api/canvas/ship', async (req, res, next) => {
var { foto1, foto2, fundo, mat } = req.query
if(!foto1) return res.json({message: "Faltando o parÃ¢metro foto 1"})
if(!foto2) return res.json({message: "Faltando o parÃ¢metro foto 2"})
if(!mat) return res.json({message: "Faltando o parÃ¢metro mat"})
if(!fundo) return res.json({message: "Faltando o parÃ¢metro fundo"})
let shiplv = await new Canvasfy.Ship()
    .setAvatars(foto1, foto2)
    .setBackground("image", fundo)
    .setBorder("#f0f0f0")
    .setOverlayOpacity(0.2)
    .setCustomNumber(Number(mat))
    .build();

require('fs').writeFileSync(bla + '/assets/Tempo/welkom.png', shiplv, 'base64')
res.sendFile(bla + '/assets/Tempo/welkom.png')
})

app.get('/api/canvas/tweed', async (req, res, next) => {
var { theme, name, username, verified, message, perfil } = req.query
th = theme.toLowerCase()
let tweedcv = await new Canvasfy.Tweet()
.setTheme((th == `black` || th == `preto`) ? `dark` : (th == `white` || white == `branco`) ? `light` : `dim`)//"dark", "light" and "dim"
.setUser({displayName: name, username: username})
.setVerified(verified && (verified == `s` || verified == `y`) ? true : false)
.setComment(message)
.setAvatar(perfil)
.build();

require('fs').writeFileSync(bla + '/assets/Tempo/welkom.png', tweedcv, 'base64')
res.sendFile(bla + '/assets/Tempo/welkom.png')
})

app.get('/welcome', async (req, res, next) => {
if (!req.query.titulo) return res.json({ status: 404, error: 'Insira o parametro: titulo'})
if (!req.query.nome) return res.json({ status: 404, error: 'Insira o parametro: nome'})
if (!req.query.perfil) return res.json({ status: 404, error: 'Insira o parametro: perfil'})
if (!req.query.fundo) return res.json({ status: 404, error: 'Insira o parametro: fundo'})
if (!req.query.grupo) return res.json({ status: 404, error: 'Insira o parametro: grupo'})

let welcomer = await new canvasx.Welcome()
.setUsername(req.query.nome)
.setDiscriminator("2024")
.setText("title", req.query.titulo)
.setText("message", req.query.grupo)
.setAvatar(req.query.perfil)
.setColor('border', '#00100C')
.setColor('username-box', '#00100C')
.setColor('discriminator-box', '#00100C')
.setColor('message-box', '#00100C')
.setColor('title', '#00FFFF')
.setBackground(req.query.fundo)
.toAttachment()
let base64 = `${welcomer.toBuffer().toString('base64')}`
require('fs').writeFileSync(bla+'/assets/welkom.png', base64, 'base64')
res.sendFile(bla+'/assets/welkom.png')
})

app.get('/api/canvas/jxr/welcome', async (req, res, next) => {
  var { nome, guilda, perfil, membro, avatar, fundo } = req.query
  if(!nome) return res.json({resultado: "Faltando o parÃ¢metro nome"})
  if(!guilda) return res.json({resultado: "Faltando o parÃ¢metro guilda"})
  if(!perfil) return res.json({resultado: "Faltando o parÃ¢metro perfil"})
  if(!membro) return res.json({resultado: "Faltando o parÃ¢metro membro"})
  if(!avatar) return res.json({resultado: "Faltando o parÃ¢metro avatar"})
  if(!fundo) return res.json({resultado: "Faltando o parÃ¢metro fundo"})
  let imagejxr = await new JXR.Welcome()
  .setUsername(nome)
  .setGuildName(guilda)
  .setGuildIcon(perfil)
  .setMemberCount(`${membro}`)
  .setAvatar(avatar)
  .setBackground(fundo)
  .toAttachment();

  let datajxr = `${imagejxr.toBuffer().toString('base64')}`
  require('fs').writeFileSync(bla+'/assets/welkom.png', datajxr, 'base64')
  res.sendFile(bla+'/assets/welkom.png')
})

app.get('/api/canvas/jxr/welcome2', async (req, res, next) => {
  var { nome, grupo, perfil, membro, fundo } = req.query
  if(!nome) return res.json({resultado: "Faltando o parÃ¢metro nome"})
  if(!grupo) return res.json({resultado: "Faltando o parÃ¢metro guilda"})
  if(!perfil) return res.json({resultado: "Faltando o parÃ¢metro perfil"})
  if(!membro) return res.json({resultado: "Faltando o parÃ¢metro membro"})
  if(!fundo) return res.json({resultado: "Faltando o parÃ¢metro fundo"})
  var imagejxr2 = await new JXR.Welcome2()
    .setAvatar(perfil)
    .setUsername(nome)
    .setBg(fundo)
    .setGroupname(grupo)
    .setMember(membro)
    .toAttachment();

  let datajxr2 = `${imagejxr2.toBuffer().toString('base64')}`
  require('fs').writeFileSync(bla+'/assets/welkom.png', datajxr2, 'base64')
  res.sendFile(bla+'/assets/welkom.png')
})

app.get('/api/canvas/musicardbun/music', async (req, res, next) => {
  var { nome, autor, tipo , opacity, thumb, progresso, start, end } = req.query
  const cardmusic = new musicCard()
        .setName(nome)
        .setAuthor(autor)
        .setColor("auto")
        .setTheme(tipo == `space2` ? `space+` : tipo)
        .setBrightness(Number(opacity))
        .setThumbnail(thumb)
        .setProgress(Number(progresso))
        .setStartTime(start)
        .setEndTime(end)
        const cardBuffer = await cardmusic.build();
        require('fs').writeFileSync(bla + '/assets/Tempo/welkom.png', cardBuffer, 'base64')
        return res.sendFile(bla + '/assets/Tempo/welkom.png')
})

app.get('/api/canvas/musicardbun/level', async (req, res, next) => {
  var { nome, level, brightness, perfil, rank, xpb, xpa, progresso } = req.query
  const cardlvmb = new RankCard()
  .setName(nome)
  .setLevel(level)
  .setColor("auto")
  .setBrightness(Number(brightness))
  .setAvatar(perfil)
  .setProgress(Number(progresso))
  .setRank(rank)
  .setCurrentXp(xpb)
  .setRequiredXp(xpa)
  .setShowXp(true);
        require('fs').writeFileSync(bla + '/assets/Tempo/welkom.png', (await cardlvmb.build()), 'base64')
        return res.sendFile(bla + '/assets/Tempo/welkom.png')
})

app.get('/api/canvas/canvacard/rank', async (req, res, next) => {
  var { nome, level, stts, perfil, rank, xpb, xpa, fundo } = req.query
  const rankcc = new canvacard.Rank()
  .setAvatar(perfil)
  .setBackground('IMAGE', fundo)
  .setCurrentXP(Number(xpb), "#00BFFF")
  .setRequiredXP(Number(xpa), "#00BFFF")
  .setRank(Number(rank))
  .setRankColor("#FFFFFF", "#00BFFF")
  .setLevel(Number(level), `LEVEL `)
  .setLevelColor("#FFFFFF", "#00BFFF")
  .setStatus(stts, true)
  .setOverlay("#23272A", 0.75, true)
  .setProgressBar(["#1E90FF", "#00BFFF"], "GRADIENT")
  .setProgressBarTrack("#000000")
  .setUsername(nome)
  .renderEmojis(true)

        require('fs').writeFileSync(bla + '/assets/Tempo/welkom.png', (await rankcc.build()), 'base64')
        return res.sendFile(bla + '/assets/Tempo/welkom.png')
})

app.get('/api/canvas/welcomify/welcome', async (req, res, next) => {
  var { title, nome, hex, perfil, message, fundo } = req.query
  const welcomifycard = new Card()
    .setTitle(title)
    .setName(nome)
    .setAvatar(perfil)
    .setMessage(message)
    .setBackground(fundo)
    .setColor(hex)

        require('fs').writeFileSync(bla + '/assets/Tempo/welkom.png', (await welcomifycard.build()), 'base64')
        return res.sendFile(bla + '/assets/Tempo/welkom.png')
})

app.get('/api/canvas/wppphoto', async (req, res, next) => {
  var { nick, number, bio, ultimovisto, foto } = req.query
  ABC = await fetchJson(`https://tohka.tech/api/canvas/perfilzap?nome=${nick}&numero=${number}&bio=${bio}&horas=${ultimovisto}&perfil=${foto}&apikey=matheuzinho2006`)

        require('fs').writeFileSync(bla + '/assets/Tempo/welkom.png', ABC, 'base64')
        return res.sendFile(bla + '/assets/Tempo/welkom.png')
})

app.get('/imagem/qrcode', async (req, res, next) => {
var { texto, apikey } = req.query
if(!texto || !apikey) return res.json({erro: "Link incompleto"})
if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
RegisKey(apikey, req);
try {
    hasil = `https://api.qrserver.com/v1/create-qr-code/?size=500x500&data=${texto}`
	  data = await fetch(hasil).then(v => v.buffer())   
         await fs.writeFileSync(bla+'/assets/gostosinha.jpg', data)
        res.sendFile(bla+'/assets/gostosinha.jpg') 
} catch (error) {
return res.status(404).json({resultado: `Erro`, status: 500});
}
}) 

app.get('/imagem/leitor-qrcode', async(req, res, next) => {
var { qrcode, apikey } = req.query
if(!qrcode || !apikey) return res.json({erro: "Link incompleto"})
if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
RegisKey(apikey, req);
data = await fetchJson(`https://api.lolhuman.xyz/api/read-qr?apikey=GataDios&img=${qrcode}`)
res.json({
status: true,
criador: `@m4thxyz_`,
resultado: data.result
})
})

app.get('/api/photo/collage', async(req, res) => {
var { url1, ulr2, url3, url4, url5 } = req.query
try {
var photo = {
  width: '600px',
  height: ['250px', '170px'],
  layout: [1, 4],
  photos: [
    { source: url1 },
    { source: url2 },
    { source: url3 },
    { source: url4 },
    { source: url5 }
  ],
  showNumOfRemainingPhotos: true
}
data = await fetch(photo).then(v => v.buffer())
await fs.writeFileSync(bla+'/assets/gostosinha.jpg', data)
res.sendFile(bla+'/assets/gostosinha.jpg')
} catch(e) {
console.log(e)
res.json({resultado: `Erro`})
}
})

app.get('/api/aptoide', async(req, res) => {
var { query, apikey } = req.query
if(!query) return res.json({resultado: `KD o parÃ¢metro query?`})
if(!apikey) return res.json({resultado: `KD o parÃ¢metro apikey?`})
if(!key.map(i => i.apikey)?.includes(apikey)) return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
RegisKey(apikey, req);
try {
ABC = await fetchJson(`https://ws75.aptoide.com/api/7/apps/search?query=${encodeURI(query)}&trusted=true`)
res.json({criador: `@m4thxyz_`, resultado: ABC.datalist.list})
} catch(e) {
console.log(e)
res.json({resultado: `Erro`})
}
})

app.get('/api/eletronica.mp3', (req, res) => {
json = fs.readFileSync('./base de dados/audios/eletronica.mp3')
res.type('mp3')
res.send(json)
})

app.get('/loli', (req, res) => {
(async() => {
json = JSON.parse(fs.readFileSync('lib/lolis.json').toString())
random = json[Math.floor(Math.random() * json.length)]
res.type('jpg')
res.send(await getBuffer(random))
})()
})

app.get('/shota', (req, res) => {
(async() => {
json = JSON.parse(fs.readFileSync(bla+'/base de dados/shotas.json').toString())
random = json[Math.floor(Math.random() * json.length)]
res.type('jpg')
res.send(await getBuffer(random))
})()
})

app.get('/random/metadinha', async (req, res, next) => {
      var apikey = req.query.apikey;
if(!apikey)return res.json({status:false,message:'- CadÃª o parÃ¢metro apikey?'})
if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
RegisKey(apikey, req);
         json = JSON.parse(fs.readFileSync(bla +'/base de dados/metadinha.json').toString())
         random = json[Math.floor(Math.random() * json.length)]
         res.json(random) 
})

app.get('/+18/loli', (req, res) => {
(async() => {
json = JSON.parse(fs.readFileSync('lib/nsfwlolis.json').toString())
random = json[Math.floor(Math.random() * json.length)]
res.type('jpg')
res.send(await getBuffer(random))
})()
})

app.get('/+18/video/random', (req, res) => {
var { mod, apikey } = req.query
if(!mod) return res.json({resultado: "Faltando o parÃ¢metro mod"})
if(!apikey) return res.json({resultado: "Faltando o parÃ¢metro apikey"})
if(!key.map(i => i.apikey)?.includes(apikey)) return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({resultado: "Apikey invÃ¡lida ou requests esgotados!"})
/*data = await fetch(video).then(v => v.buffer())
await fs.writeFileSync(bla+'/assets/asupan.mp4', data)
res.sendFile(bla+'/assets/asupan.mp4')*/
})

app.get('/api/noticias/find', async(req, res, next) => {
var { q, apikey } = req.query
if(!q) return res.json({resultado: "Faltando o parÃ¢metro q"})
if(!apikey) return res.json({resultado: "Faltando o parÃ¢metro apikey"})
if(!key.map(i => i.apikey)?.includes(apikey)) return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({resultado: "Apikey invÃ¡lida ou requests esgotados!"})
RegisKey(apikey, req);
try {
  theNews = await axios.get(`https://newsapi.org/v2/everything?q=${q}&sortBy=publishedAt&language=pt&apiKey=9dc1dde158804756ae9b33dd8d71f7a1`);
  newsSends = theNews.data.articles.map(d => `${d.publishedAt.split('T').join(' - ').split('Z')[0]}\n\n${d.title} - ${d.author} [${d.source.name}]\n\n${d.description}\n\n${d.url}\n\n${d.content}\n\n--------------------------- * ---------------------------\n\n`).join('');
  return res.json({criador: "@m4thxyz_", resultado: newsSends})
} catch {
  return res.json({resultado: "Erro"})
}
})

app.get('/api/book', async(req, res) => {
var { livro, apikey } = req.query
try {
ABC = await fetchJson(`https://www.googleapis.com/books/v1/volumes?q=${livro}&langRestrict=pt`);
return res.json({status: true, criador: "@m4thxyz_", resultado: ABC.items})
} catch { return res.json({status: false, resultado: "Nenhuma resposta obtida do servidor"}) }
})

app.get('/api/cotacao', async(req, res) => {
var { moeda, apikey } = req.query
if(!moeda || !apikey) return res.json({erro: "Faltando parÃ¢metro moeda ou apikey"})
moda = moeda.toLowerCase().replace("Ã³", "o")
try {
if(moda == "dolar") { money = "USD-BRL"
} else if(moda == "euro") { money = "EUR-BRL"
} else if(moda == "bitcoin") { money = "BTC-BRL"
} else if(moda == "libra") { money = "GBP-BRL"
} else if(moda == "ether") { money = "ETH-BRL"
} else if(moda == "iene") { money = "JPY-BRL"
} else if(moda == "yuan") { money = "CNY-BRL"
} else return res.json({erro: `A moeda escolhida nÃ£o estÃ¡ presente em meu banco de dados... As moedas disponÃ­veis sÃ£o:
â€¢ DÃ³lar
â€¢ Euro
â€¢ Bitcoin
â€¢ Libra
â€¢ Ether
â€¢ Iene
â€¢ Yuan`})
response = await axios.get(`https://economia.awesomeapi.com.br/last/${money}`);
if(moda == "dolar") { resposta = response.data.USDBRL
} else if(moda == "euro") { resposta = response.data.EURBRL
} else if(moda == "bitcoin") { resposta = response.data.BTCBRL
} else if(moda == "ether") { resposta = response.data.ETHBRL
} else if(moda == "libra") { resposta = response.data.GBPBRL
} else if(moda == "iene") { resposta = response.data.JPYBRL
} else if(moda == "yuan") { resposta = response.data.CNYBRL }
return res.json({status: true, criador: "@m4thxyz_", resultado: [resposta]})
} catch { return res.json({status: false, erro: "Nenhuma resposta obtida do servidor"}) }
})

app.get('/nsfw/image/random', async(req, res) => {
var { atriz, apikey } = req.query
if(!atriz) return res.json({resultado: "Faltando o parÃ¢metro atriz"})
if(!apikey) return res.json({resultado: "Faltando o parÃ¢metro apikey"})
if(!key.map(i => i.apikey)?.includes(apikey)) return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({resultado: "Apikey invÃ¡lida ou requests esgotados!"})

try {
	  data = await fetch(img).then(v => v.buffer())   
         await fs.writeFileSync(bla+'/assets/gostosinha.jpg', data)
        res.sendFile(bla+'/assets/gostosinha.jpg')
} catch {
  return res.json({status: false, criador: "@m4thxyz_", resultado: "Erro"})
}
})

app.get('/api/facebook', async(req, res, next) => {
apikey = req.query.apikey;
url = req.query.url
 if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
 if (!url) return res.json({ status : false,  message: "Coloque o parametro: url"})
 RegisKey(apikey, req);
fbdown(url).then(data => {
res.json({
status: true,
cÃ³digo: 999,
resultado: data
})}).catch(e => {
res.json({
message: `Erro no Servidor Interno`
})})})

app.get('/api/celular', async(req, res) => {
try {
nome = req.query.nome
if(!nome)return res.json({status:false, motivo:'Coloque o parÃ¢metro: nome'})
apikey = req.query.apikey;
if(!apikey)return res.json({status:false,message:'- CadÃª o parÃ¢metro apikey?'})
if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
RegisKey(apikey, req);
axios(`https://www.techtudo.com.br/busca/?q=`+nome, Headers={headers}).then(rs => {
var $ = cheerio.load(rs.data)
const DFN_UR = $(".widget--navigational__title").text().toLowerCase()
axios(`https://www.techtudo.com.br/tudo-sobre/${DFN_UR.replace(new RegExp(" ", "gi"), "-")}/`, Headers={headers}).then(rsp => {
var $ = cheerio.load(rsp.data)  
var RST = []
var titulo = $("h1").text()
var BT = $("div").find(".content-row").text()
var BT2 = $("div").find(".all-about").text()
res.json({status: true, cÃ³digo: 999, criador: `@m4thxyz_`, resultado: {title: titulo, info: BT2.trim(), resumo: BT.trim().replace(new RegExp("  ", "gi"), "\n\n")}})}).catch(e => {res.json({message: "Error"})})}).catch(e => {res.json({message: "Error"})})} catch {return res.json({message: "Erro...Aguarde ou fale com algum administrador.."})}})

app.get('/api/horoscopo/v2', async (req, res) => {
try {
apikey = req.query.apikey
signo = req.query.signo
if(!signo) return res.json({message: "Faltando o parametro signo"})
if(!apikey)return res.json({message:'cade o parametro apikey'})
if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
DFN_SG = signo.toLowerCase().normalize('NFD').replace(/[\u0300-\u036f]/g, "")
if(!JSON.stringify(["aries", "touro", "gemeos", "cancer", "leao", "virgem", "libra", "escorpiao", "sagitario", "capricornio", "aquario", "peixes"]).includes(DFN_SG)) return res.json({message: "Este signo nÃ£o existe, os signos existentes sÃ£o: Ãries, Touro, GÃªmeos, CÃ¢ncer, LeÃ£o, Virgem, Libra, EscorpiÃ£o, SagitÃ¡rio, CapricÃ³rnio, AquÃ¡rio e Peixes."})
var { horoshoje } = require("./base de dados/horoscopo.js");
RegisKey(apikey, req);
await horoshoje(DFN_SG).then(signo => {
res.json({status: 200, resultado: {thumb: signo.imagem, title: signo.tÃ­tulo, info: signo.inform}})
}).catch(e => {
return res.json({message: "Erro.."})
})
} catch (e) {
return res.json({message: "Erro.."})
}
})

app.get('/api/emojimix2', async(req, res) => {
var { emoji1, emoji2, apikey } = req.query
if(!apikey)return res.json({message:'cade o parametro apikey'})
try {
caliphapi.other.emojimix(emoji1, emoji2).then(ABC => {
res.json({resultado: ABC})
})
} catch(e) { console.log(e)
res.json({resultado: `Erro`}) }
})

app.get('/api/v4/instagram', async(req, res) => {
var { url, apikey } = req.query
if(!apikey)return res.json({message:'cade o parametro apikey'})
caliphapi.downloader.instagram(url).then(ABC => {
res.json({resultado: ABC})
}).catch(e => {
console.log(e)
res.json({resultado: `Erro`})
})
})

app.get('/search/wikipedia',(req,res) => {
query = req.query.query
if(!query)return res.json({
status:false,
message:'CadÃª o parÃ¢metro: QUERY'
})
apikey = req.query.apikey
if(!apikey)return res.json({status:false,message:'CadÃª o parÃ¢metro: APIKEY'})
if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
RegisKey(apikey, req);
wikiSearch(query)
.then(hasil => {
res.json({
status:true,
resultado: hasil
})
}).catch(e => {
res.json({erro:'Erro no Servidor Interno'})
})
})

app.get('/search/pensador',(req,res) => {
query = req.query.query
if(!query)return res.json({
status:false,
message:'CadÃª o parÃ¢metro: QUERY'
})
apikey = req.query.apikey
if(!apikey)return res.json({status:false,message:'CadÃª o parÃ¢metro: APIKEY'})
if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
RegisKey(apikey, req);
pensadorSearch(query)
.then(dados => {
res.json({
status:true,
resultado: dados
})
}).catch(e => {
res.json({erro:'Erro no Servidor Interno'})
})
})

app.get('/search/wallpaper',(req,res) => {
query = req.query.query
if(!query)return res.json({
status:false,
message:'CadÃª o parÃ¢metro: QUERY'
})
apikey = req.query.apikey
if(!apikey)return res.json({status:false,message:'CadÃª o parÃ¢metro: APIKEY'})
if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
RegisKey(apikey, req);
wallpaper2(query)
.then(result => {
res.json({
status:true,
resultado: result
})
}).catch(e => {
res.json({erro:'Erro no Servidor Interno'})
})
})

app.get('/download/tiktok2',(req,res) => {
url = req.query.url
if(!url)return res.json({
status:false,
message:'CadÃª o parÃ¢metro: URL'
})
apikey = req.query.apikey
if(!apikey)return res.json({status:false,message:'CadÃª o parÃ¢metro: APIKEY'})
if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
RegisKey(apikey, req);
tiktok2(url).then(result => {
res.json({
status:true,
resultado: result
})
}).catch(e => {
res.json({erro:'Erro no Servidor Interno'})
})
})

app.get('/download/tiktok3',(req,res) => {
url = req.query.url
if(!url)return res.json({
status:false,
message:'CadÃª o parÃ¢metro: URL'
})
apikey = req.query.apikey
if(!apikey)return res.json({status:false,message:'CadÃª o parÃ¢metro: APIKEY'})
if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
RegisKey(apikey, req);
tiklydown(url).then(result => {
res.json({
status:true,
result
})
}).catch(e => {
res.json({erro:'Erro no Servidor Interno'})
})
})

app.get('/download/tiktok4',(req,res) => {
url = req.query.url
if(!url)return res.json({
status:false,
message:'CadÃª o parÃ¢metro: URL'
})
apikey = req.query.apikey
if(!apikey)return res.json({status:false,message:'CadÃª o parÃ¢metro: APIKEY'})
if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
RegisKey(apikey, req);
tikmate(url).then(result => {
res.json({
status:true,
result
})
}).catch(e => {
res.json({erro:'Erro no Servidor Interno'})
})
})

app.get('/download/youtube',(req,res) => {
url = req.query.url
if(!url)return res.json({
status:false,
message:'CadÃª o parÃ¢metro: url'
})
apikey = req.query.apikey
if(!apikey)return res.json({status:false,message:'CadÃª o parÃ¢metro: apikey'})
if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
RegisKey(apikey, req);
ytDonlodMp3_3(url).then(result => {
res.json({
status:true,
resultado: result
})
}).catch(e => {
res.json({erro:'Erro no Servidor Interno'})
})
})

app.get('/download/tiktok', async(req, res, next) => {
apikey = req.query.apikey;
url = req.query.url
 if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
 if (!url) return res.json({ status : false,  message: "Coloque o parametro: url"})
 RegisKey(apikey, req);
testing.musically(url).then(data => {
res.json({
status: true,
cÃ³digo: 999,
resultado: data
})}).catch(e => {
res.json({
message: `Erro no Servidor Interno`
})})})

app.get('/api/tiktokdl', async(req, res) => {
var { url, apikey } = req.query
if(!url) return res.json({status:false,message:'CadÃª o parÃ¢metro: URL'})
if(!apikey) return res.json({status:false,message:'CadÃª o parÃ¢metro: APIKEY'})
if(!key.map(i => i.apikey)?.includes(apikey)) return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
RegisKey(apikey, req);
tiktokapidl.Downloader(url, {version: `v1`}).then(ABC => {
res.json({criador: `@m4thxyz_`, resultado: ABC.result})
}).catch(e => {
console.log(e)
res.json({resultado: `Erro`})
})
})

app.get('/api/tiktokdl2', async(req, res) => {
var { url, apikey } = req.query
if(!url) return res.json({status:false,message:'CadÃª o parÃ¢metro: URL'})
if(!apikey) return res.json({status:false,message:'CadÃª o parÃ¢metro: APIKEY'})
if(!key.map(i => i.apikey)?.includes(apikey)) return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
RegisKey(apikey, req);
tiktokapidl.Downloader(url, {version: `v2`}).then(ABC => {
res.json({criador: `@m4thxyz_`, resultado: ABC.result})
}).catch(e => {
console.log(e)
res.json({resultado: `Erro`})
})
})

app.get('/api/tiktokdl3', async(req, res) => {
var { url, apikey } = req.query
if(!url) return res.json({status:false,message:'CadÃª o parÃ¢metro: URL'})
if(!apikey) return res.json({status:false,message:'CadÃª o parÃ¢metro: APIKEY'})
if(!key.map(i => i.apikey)?.includes(apikey)) return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
RegisKey(apikey, req);
tiktokapidl.Downloader(url, {version: `v3`}).then(ABC => {
res.json({criador: `@m4thxyz_`, resultado: ABC.result})
}).catch(e => {
console.log(e)
res.json({resultado: `Erro`})
})
})

app.get('/api/letramusic',(req,res) => {
query = req.query.query
if(!query)return res.json({
status:false,
message:'CadÃª o parÃ¢metro: query'
})
apikey = req.query.apikey
if(!apikey)return res.json({status:false,message:'CadÃª o parÃ¢metro: APIKEY'})
if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
RegisKey(apikey, req);
lirik(query).then(hasil => {
res.json({
status:true,
resultado: hasil
})
}).catch(e => {
console.log(e)
res.json({erro:'Erro no Servidor Interno'})
})
})

app.get('/api/letramusic2',(req,res) => {
query = req.query.query
if(!query)return res.json({
status:false,
message:'CadÃª o parÃ¢metro: query'
})
apikey = req.query.apikey
if(!apikey)return res.json({status:false,message:'CadÃª o parÃ¢metro: APIKEY'})
if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
RegisKey(apikey, req);
lyricsFinder2(query).then(data => {
res.json({
status:true,
resultado: data
})
}).catch(e => {
console.log(e)
res.json({erro:'Erro no Servidor Interno'})
})
})

router.get('/api/emojimix', async (req, res, next) => {
	var emoji1 = req.query.emoji1
	var emoji2 = req.query.emoji2
	apikey = req.query.apikey
if(!apikey)return res.json({status:false,message:'CadÃª o parÃ¢metro: APIKEY'})
	if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
	if (!emoji1) return res.json({ status : false, message : "[!] parÃ¢metros de entrada  emoji1"})
	if (!emoji2) return res.json({ status : false, message : "[!] parÃ¢metros de entrada  emoji2"})  
	RegisKey(apikey, req);
	let data = await Kibar(`https://tenor.googleapis.com/v2/featured?key=AIzaSyAyimkuYQYF_FXVALexPuGQctUWRURdCYQ&contentfilter=high&media_filter=png_transparent&component=proactive&collection=emoji_kitchen_v5&q=${encodeURIComponent(emoji1)}_${encodeURIComponent(emoji2)}`)
	let jadi = data.results[Math.floor(Math.random() * data.results.length)]
	if (!jadi ) return res.json({erro: "Erro no Servidor Interno."})
	for (let ress of data.results) {
	resul = await getBuffer(ress.url)
	res.set({'Content-Type': 'image/png'})
	res.send(resul)
}
})


app.get('/download/facebook', async(req, res, next) => {
apikey = req.query.apikey;
url = req.query.url
 if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
 if (!url) return res.json({ status : false,  message: "Coloque o parametro: url"})
 RegisKey(apikey, req);
FacebookMp4(url).then(resultado => {
res.json(resultado)
}).catch(e => {
res.json({
message: `Erro no Servidor Interno`
})
})
})

app.get('/download/facebook2', async(req, res, next) => {
apikey = req.query.apikey;
url = req.query.url
 if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
 if (!url) return res.json({ status : false,  message: "Coloque o parametro: url"})
 RegisKey(apikey, req);
getmyfb(url).then(resultado => {
res.json(resultado)
}).catch(e => {
res.json({
message: `Erro no Servidor Interno`
})
})
})

app.get('/api/v3/facebook', async(req, res, next) => {
apikey = req.query.apikey;
url = req.query.url
if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
if(!url) return res.json({ status : false,  message: "Coloque o parametro: url"})
RegisKey(apikey, req);
try {
ABC = await facebook(url)
res.json({criador: `@m4thxyz_`, resultado: ABC.result})
} catch(e) {
console.log(e)
res.json({resultado: `Erro`})
}
})

app.get('/api/filme', async(req, res, next) => {
apikey = req.query.apikey;
q = req.query.q
 if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
 if (!q) return res.json({ status : false,  message: "Coloque o parametro: q"})
 RegisKey(apikey, req);
filme(q).then(resultado => {
res.json({
status: true,
cÃ³digo: 200,
criador: `@m4thxyz_`,
pesquisa: resultado
})}).catch(e => {
res.json({
message: `Erro no Servidor Interno`
})})})

app.get('/api/ph/image', async(req, res) => {
var { category, apikey } = req.query
if(!category) return res.json({message: "Faltando o parÃ¢metro category"})
if(!apikey) return res.json({message: "Faltando o parÃ¢metro apikey"})
if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
RegisKey(apikey, req);
try {
var nsfw = new NSFW()
nsfw.fetch(category).then((data) => {
async function convertph(hehe) {
img = await fetch(hehe).then(v => v.buffer())   
await fs.writeFileSync(bla+'/assets/gostosinha.jpg', img)
res.sendFile(bla+'/assets/gostosinha.jpg') 
}
return convertph(data.image.url)
//return res.json({criador: "@m4thxyz_", status: true, resultado: data.image.url})
})
} catch(e) { console.log(e)
return res.json({criador: "@m4thxyz_", status: false, resultado: `Erro`}) }
})

app.get('/api/ph/image2', async(req, res) => {
var { category, apikey } = req.query
if(!category) return res.json({message: "Faltando o parÃ¢metro category"})
if(!apikey) return res.json({message: "Faltando o parÃ¢metro apikey"})
if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
RegisKey(apikey, req);
try {
var nsfw = new NSFW()
nsfw.fetch(category).then((data) => {
return res.json({criador: "@m4thxyz_", status: true, resultado: data.image.url})
})
} catch(e) { console.log(e)
return res.json({criador: "@m4thxyz_", status: false, resultado: `Erro`}) }
})

app.get('/api/xvsearch', async(req, res) => {
var { q, apikey } = req.query
if(!q) return res.json({message: "Faltando o parÃ¢metro q"})
if(!apikey) return res.json({message: "Faltando o parÃ¢metro apikey"})
if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
RegisKey(apikey, req);
try {
var xv =  await xvideoss(q)
caixa = []
for(i of xv.result) {
caixa.push({titulo: i.title, duracao: i.duration, link: i.url, thumbnail: i.thumb})
}
return res.json({criador: "@m4thxyz_", status: true, resultado: caixa})
} catch(e) { console.log(e)
  return res.json({criador: "@m4thxyz_", status: false, resultado: []}) }
})

app.get('/api/xvideos', async(req, res) => {
var { url, apikey } = req.query
if(!url) return res.json({message: "Faltando o parÃ¢metro url"})
if(!apikey) return res.json({message: "Faltando o parÃ¢metro apikey"})
if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
RegisKey(apikey, req);
try {
const { xvideosDownloader } = require("./base de dados/xvideos.js")
ABC = await xvideosDownloader(url);
return res.json({criador: "@m4thxyz_", resultado: {titulo: ABC.resultado.titulo, desc: ABC.resultado.desc, thumbnail: ABC.resultado.thumb, download: ABC.resultado.link}})
} catch(e) { console.log(e)
return res.json({erro: "Erro no servidor interno"}) }
})

app.get('/api/xnxx', async(req, res) => {
var { q, apikey } = req.query
if(!q) return res.json({message: "Faltando o parÃ¢metro q"})
if(!apikey) return res.json({message: "Faltando o parÃ¢metro apikey"})
if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
RegisKey(apikey, req);
try {
var xnxx =  await xnxxs(q)
return res.json({criador: "@m4thxyz_", status: true, resultado: xnxx.result})
} catch(e) { console.log(e)
  return res.json({criador: "@m4thxyz_", status: false, resultado: []}) }
})

app.get('/api/xnxxdl', async(req, res) => {
var { url, apikey } = req.query
if(!url) return res.json({message: "Faltando o parÃ¢metro url"})
if(!apikey) return res.json({message: "Faltando o parÃ¢metro apikey"})
if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
RegisKey(apikey, req);
try {
var xnxx =  await xnxxdl(url)
return res.json({criador: "@m4thxyz_", resultado: xnxx.result})
} catch(e) { console.log(e)
return res.json({erro: "Erro no servidor interno"}) }
})

app.get('/api/phsearch', async(req, res) => {
var { q, apikey } = req.query
if(!q) return res.json({message: "Faltando o parÃ¢metro q"})
if(!apikey) return res.json({message: "Faltando o parÃ¢metro apikey"})
if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
RegisKey(apikey, req);
try {
var pornhub = new PornHub()
var ph = await pornhub.searchVideo(q)
return res.json({criador: "@m4thxyz_", status: true, resultado: ph.data})
} catch(e) { console.log(e)
return res.json({criador: "@m4thxyz_", status: false, resultado: []}) }
})

app.get('/api/pornhub', async(req, res) => {
var { url, apikey } = req.query
if(!url) return res.json({message: "Faltando o parÃ¢metro url"})
if(!apikey) return res.json({message: "Faltando o parÃ¢metro apikey"})
if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
RegisKey(apikey, req);
try {
var pornhub = new PornHub()
var ph = await pornhub.video(url)
return res.json({criador: "@m4thxyz_", result: ph})
} catch(e) { console.log(e)
return res.json({erro: "Erro no servidor interno"}) }
})

app.get('/api/nerding', async(req, res, next) => {
apikey = req.query.apikey;
q = req.query.q
 if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
 if (!q) return res.json({ status : false,  message: "Coloque o parametro: q"})
 RegisKey(apikey, req);
 nerding(q).then(resultado => {
res.json({status: true, cÃ³digo: 200, criador: `@m4thxyz_`, resultado: resultado})
}).catch(e => {
res.json({
message: `Erro no Servidor Interno`
})})})


app.get('/api/playstore', async(req, res, next) => {
apikey = req.query.apikey;
nome = req.query.nome
 if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
 if (!nome) return res.json({ status : false,  message: "Coloque o parametro: nome"})
 RegisKey(apikey, req);
PlayStoreSearch(nome).then(data => {
res.json({
pesquisa: data
})}).catch(e => {
res.json({
message: `Erro no Servidor Interno`,
erro: `${e}`
})})})

app.get('/api/mercadolivre', async(req, res, next) => {
apikey = req.query.apikey;
nome = req.query.nome
 if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
 if (!nome) return res.json({ status : false,  message: "Coloque o parametro: nome"})
 RegisKey(apikey, req);
MercadoLivreSearch(nome).then(data => {
res.json(data)
}).catch(e => {
res.json({
message: `Erro no Servidor Interno`,
erro: `${e}`
})})})

app.get('/api/amazon', async(req, res, next) => {
apikey = req.query.apikey;
nome = req.query.nome
 if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
 if (!nome) return res.json({ status : false,  message: "Coloque o parametro: nome"})
 RegisKey(apikey, req);
AmazonSearch(nome).then(data => {
res.json(data)
}).catch(e => {
res.json({
message: `Erro no Servidor Interno`,
erro: `${e}`
})})})

app.get('/api/americanas', async(req, res, next) => {
apikey = req.query.apikey;
nome = req.query.nome
 if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
 if (!nome) return res.json({ status : false,  message: "Coloque o parametro: nome"})
 RegisKey(apikey, req);
AmericanasSearch(nome).then(data => {
res.json(data)
}).catch(e => {
res.json({
message: `Erro no Servidor Interno`,
erro: `${e}`
})})})

app.get('/api/dicionario', async(req, res, next) => {
apikey = req.query.apikey;
q = req.query.q
 if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
 if (!q) return res.json({ status : false,  message: "Coloque o parametro: q"})
 RegisKey(apikey, req);
Dicionario(q).then(data => {
res.json(data)
}).catch(e => {
res.json({
message: `Erro no Servidor Interno`,
erro: `${e}`
})})})

app.get('/api/pinterest_mp4', async(req, res, next) => {
apikey = req.query.apikey;
url = req.query.url
 if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
 if (!url) return res.json({ status : false,  message: "Coloque o parametro: url"})
 RegisKey(apikey, req);
pinterestVideoV2(url).then(data => {
res.json({
pesquisa: data
})}).catch(e => {
res.json({
message: `Erro no Servidor Interno`
})})})

app.get('/api/ytplaylist', async(req, res, next) => {
apikey = req.query.apikey;
url = req.query.url
 if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
 if (!url) return res.json({ status : false,  message: "Coloque o parametro: url"})
 RegisKey(apikey, req);
getVideosPlaylist(url).then(resJson => {
res.json({
status: 200,
resultado: resJson
})
}).catch(e => {
res.json({
message: `Erro no Servidor Interno`
})
})
})

app.get('/api/submarino', async(req, res, next) => {
apikey = req.query.apikey;
nome = req.query.nome
 if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
 if (!nome) return res.json({ status : false,  message: "Coloque o parametro: nome"})
 RegisKey(apikey, req);
SubmarinoSearch(nome).then(dados => {
res.json({
pesquisa: data
})}).catch(e => {
res.json({
message: `Erro no Servidor Interno`
})})})


app.get('/api/horoscopo', async(req, res, next) => {
apikey = req.query.apikey;
signo = req.query.signo
 if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
 if (!signo) return res.json({ status : false,  message: "Coloque o parametro: signo"})
 RegisKey(apikey, req);
Horoscopo(signo).then(data => {
res.json({
pesquisa: data
})}).catch(e => {
res.json({
message: `Erro no Servidor Interno`
})})})

app.get('/api/randomgp', async(req, res, next) => {
apikey = req.query.apikey;
categoria = req.query.categoria
 if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
 if (!categoria) return res.json({ status : false,  message: "Coloque o parametro: categoria"})
 RegisKey(apikey, req);
randomGrupos(categoria).then(dados => {
res.json({
pesquisa: dados
})}).catch(e => {
res.json({
message: `Erro no Servidor Interno`
})})})

app.get('/download/kwai', async(req, res, next) => {
apikey = req.query.apikey;
url = req.query.url
 if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
 if (!url) return res.json({ status : false,  message: "Coloque o parametro: url"})
 RegisKey(apikey, req);
kwai(url).then(hasil => {
res.json(hasil)}).catch(e => {
console.log(e)
res.json({
message: `Erro no Servidor Interno`
})})})

app.get('/outros/openai', async(req, res, next) => {
apikey = req.query.apikey;
pergunta = req.query.pergunta
 if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
 if (!pergunta) return res.json({ status : false,  message: "Coloque o parametro: pergunta"})
 RegisKey(apikey, req);
InArtificial(pergunta).then(hasil => {
res.json({
status: 200,
resultado: hasil
})}).catch(e => {
res.json({
message: `Erro no Servidor Interno`
})})})

app.get('/outros/openai/corretor', async(req, res, next) => {
apikey = req.query.apikey;
texto = req.query.texto
 if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
 if (!texto) return res.json({ status : false,  message: "Coloque o parametro: texto"})
 RegisKey(apikey, req);
CorretorOpenAi(texto).then(hasil => {
res.json({
status: 200,
resultado: hasil
})}).catch(e => {
res.json({
message: `Erro no Servidor Interno`
})})})

app.get('/api/memes', async(req, res, next) => {
apikey = req.query.apikey;
 if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
RegisKey(apikey, req);
memesDroid().then(dados => {
res.json({
pesquisa: dados
})}).catch(e => {
res.json({
message: `Erro no Servidor Interno`
})})})

app.get('/api/memesvid', async(req, res, next) => {
apikey = req.query.apikey;
 if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
RegisKey(apikey, req);
iFunny().then(dados => {
res.json(dados)
}).catch(e => {
res.json({
message: `Erro no Servidor Interno`
})})})

app.get('/api/ringtone', async(req, res, next) => {
query = req.query.query
apikey = req.query.apikey;
 if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
  if (!query) return res.json({ status : false,  message: "Coloque o parametro: query"})
  RegisKey(apikey, req);
ringtone(query).then(hasil => {
res.json({
status: 200,
resultado: hasil
})}).catch(e => {
res.json({
message: `Erro no Servidor Interno`
})})})

app.get('/api/noticias/globo', async(req, res, next) => {
apikey = req.query.apikey;
 if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
RegisKey(apikey, req);
G1().then(data => {
res.json({
pesquisa: data
})}).catch(e => {
res.json({
message: `Erro no Servidor Interno`
})})})

app.get('/api/noticias/jovempan', async(req, res, next) => {
apikey = req.query.apikey;
 if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
RegisKey(apikey, req);
JovemPan().then(data => {
res.json({
pesquisa: data
})}).catch(e => {
res.json({
message: `Erro no Servidor Interno`
})})})

app.get('/api/noticias/poder360', async(req, res, next) => {
apikey = req.query.apikey;
 if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
RegisKey(apikey, req);
Poder360().then(data => {
res.json({
pesquisa: data
})}).catch(e => {
res.json({
message: `Erro no Servidor Interno`
})})})

app.get('/api/noticias/uol', async(req, res, next) => {
apikey = req.query.apikey;
 if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
RegisKey(apikey, req);
Uol().then(data => {
res.json({
pesquisa: data
})}).catch(e => {
res.json({
message: `Erro no Servidor Interno`
})})})

app.get('/api/noticias/estadao', async(req, res, next) => {
apikey = req.query.apikey;
 if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
RegisKey(apikey, req);
Estadao().then(data => {
res.json({
pesquisa: data
})}).catch(e => {
res.json({
message: `Erro no Servidor Interno`
})})})

app.get('/api/noticias/cnnbrasil', async(req, res, next) => {
apikey = req.query.apikey;
 if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
RegisKey(apikey, req);
CNNBrasil().then(data => {
res.json({
pesquisa: data
})}).catch(e => {
res.json({
message: `Erro no Servidor Interno`
})})})

app.get('/api/gpwhatsapp', async(req, res, next) => {
q = req.query.q;
apikey = req.query.apikey;
 if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
  if(!q)return res.json({status:false,message:'CadÃª o parÃ¢metro q?'})
  RegisKey(apikey, req);
 gpwhatsapp(q).then(resultado => {
res.json({
status: true,
cÃ³digo: 200,
criador: `${criador}`,
resultado: resultado
})}).catch(e => {
res.json({
message: `Erro no Servidor Interno`
})})})



app.get('/api/imitar/faustao', (req, res) => {
(async() => {
apikey = req.query.apikey
texto = req.query.texto
if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
if (!texto) return res.json({ status : false,  message : "CadÃª o parametro texto?"})
RegisKey(apikey, req);
uber.getAudioUrl("pub_motekhcekzerxfxjro", "pk_d2d564c1-7942-4afc-9368-7520fc024603", 'faustao', texto).then(async getBuf => {
res.type('mp3')
res.send(await getBuffer(getBuf))
})
})()
})

app.get('/api/imitar/ibere', (req, res) => {
(async() => {
apikey = req.query.apikey
texto = req.query.texto
if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
if (!texto) return res.json({ status : false,  message : "CadÃª o parametro texto?"})
RegisKey(apikey, req);
uber.getAudioUrl("pub_motekhcekzerxfxjro", "pk_d2d564c1-7942-4afc-9368-7520fc024603", 'ibere', texto).then(async getBuf => {
res.type('mp3')
res.send(await getBuffer(getBuf))
})
})()
})

app.get("/api/open-ai_txt", async(req, res, next) => {
async function PRGT() {
try {
var { Configuration, OpenAIApi } = require("openai") //precisa baixar o mÃ³dulo (npm i openai)
var { q, TOKEN_GPT } = req.query
var configopen = new Configuration({ apiKey: TOKEN_GPT.trim() }); //coloca sua key aqui
 var openai = new OpenAIApi(configopen); //configuraÃ§Ã£o do openai (sincronizaÃ§Ã£o da sua key)
 if(!q) return res.json({message: 'Em que posso te ajudar?, pergunte e eu te responderei ğŸ™‚'})
 if(!TOKEN_GPT) return res.json({resultado: `Faltando definir o token: &TOKEN_GPT=SEU
 TOKEN`})
 var resopen = await openai.createCompletion({
frequency_penalty: 0.5, //nÃ£o sei
max_tokens: 3000, //quantidade mÃ¡xima de palavra-chave
model: "text-davinci-003", //modelo de respostas
presence_penalty: 0, //nÃ£o sei
prompt: q, //o que deseja  
temperature: 1, //respostas exatas (nÃ£o entendi muito bem na documentaÃ§Ã£o)
top_p: 1, //nÃ£o sei
});
respgpt = resopen.data.choices[0].text.includes('\n') ? resopen.data.choices[0].text.replace('\n\n', '') : resopen.data.choices[0].text
res.json({resultado: respgpt})
} catch (e) {
console.log(e)
res.json({resultado: "Erro / Talvez seu token expirou, espere um tempo para tentar novamente."})
}
}
PRGT().catch(async(e) => {
console.log(e)
res.json({resultado: "Erro / Talvez seu token expirou, espere um tempo para tentar novamente."})
})
})

app.get("/api/open-ai_img", async(req, res, next) => {
async function PRGT2() {
try {
var { Configuration, OpenAIApi } = require("openai") //precisa baixar o mÃ³dulo (npm i openai)
var { q, TOKEN_GPT } = req.query
var configopen = new Configuration({ apiKey: TOKEN_GPT.trim()}); //coloca sua key aqui
var openai = new OpenAIApi(configopen); //configuraÃ§Ã£o do openai (sincronizaÃ§Ã£o da sua key)
 if(!q) return res.json({resultado: 'Em que posso te ajudar? PeÃ§a algo, como: hulk com raiva ğŸ™‚'})
 if(!TOKEN_GPT) return res.json({message: `Faltando definir o token: &TOKEN_GPT=SEU
 TOKEN`})
 var respimg = await openai.createImage({
 prompt: q, //o que deseja
 n: 1, //quantidade de imagem
 size: "1024x1024", //tamanho (aceita apenas: 256x256, 512x512, e 1024x1024)
 });
res.type("jpeg")
res.send(await getBuffer(respimg.data.data[0].url))
} catch {
return res.json({resultado: "Erro / Talvez seu token expirou, espere um tempo para tentar novamente."})
}
}
PRGT2().catch(async() => {
return res.json({resultado: "Erro / Talvez seu token expirou, espere um tempo para tentar novamente."})
})
})

app.get('/api/attp', async (req, res) => {
try {
texto = req.query.texto
apikey = req.query.apikey
if(!texto) return res.json({message: "Faltando o parametro texto"})
if(!apikey)return res.json({message:'cade o parametro apikey'})
if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
RegisKey(apikey, req);
await attp(texto).then(img => {
res.sendFile(img, { root: __dirname})
}).catch(e => {
return res.json({message: "Erro.. "+e})
})
} catch (e) {
return res.json({message: "Erro.. "+e})
}
})

app.get('/makerfig/rgb', async (req, res, next) => {
fig = req.query.fig
texto = req.query.texto
apikey = req.query.apikey
if(!fig) return res.json({message: "Faltando o parametro fig"})
tipos = ["attp", "attp1", "attp2", "attp3", "attp4", "attp5", "attp6"]
if(!tipos.includes(fig)) return res.json({message: "Tipo maker attp invÃ¡lido"})
if(!texto) return res.json({message: "Faltando o parametro texto"})
if(!apikey)return res.json({message:'cade o parametro apikey'})
if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
RegisKey(apikey, req);
try {
  corretor = fig == "attp" ? "attp1" : fig
    hasil = `https://api.iblgroup.cloud/api-iblcloud/${corretor}?texto=${texto}&apikey=TURBO_CONECT`
	  data = await fetch(hasil).then(v => v.buffer())   
         await fs.writeFileSync(bla+'/assets/attp.webp', data)
        res.sendFile(bla+'/assets/attp.webp') 
} catch {
return res.json({message: "Erro no server interno... Chame meu dono matheuzinho"})
}
})

app.get('/api/amongus', async (req, res, next) => {
texto = req.query.texto
apikey = req.query.apikey
if(!texto) return res.json({message: "Faltando o parametro texto"})
if(!apikey)return res.json({message:'cade o parametro apikey'})
if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
RegisKey(apikey, req);
try {
    hasil = `https://api.lolhuman.xyz/api/amongus?apikey=gataDios&text=${texto}`
	  data = await fetch(hasil).then(v => v.buffer())   
         await fs.writeFileSync(bla+'/assets/attp.webp', data)
        res.sendFile(bla+'/assets/attp.webp') 
} catch {
return res.json({message: "Erro no server interno... Chame meu dono matheuzinho"})
}
})

app.get('/api/gtapassed', async (req, res, next) => {
var { txt1, txt2, apikey } = req.query
if(!txt1) return res.json({message: "Faltando o parametro texto 1"})
if(!txt2) return res.json({message: "Faltando o parametro texto 2"})
if(!apikey)return res.json({message:'cade o parametro apikey'})
if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
RegisKey(apikey, req);
try {
    hasil = `https://api.lolhuman.xyz/api/gtapassed?apikey=gataDios&text1=${txt1}&text2=${txt2}`
	  data = await fetch(hasil).then(v => v.buffer())   
         await fs.writeFileSync(bla+'/assets/attp.webp', data)
        res.sendFile(bla+'/assets/attp.webp') 
} catch {
return res.json({message: "Erro no server interno... Chame meu dono matheuzinho"})
}
})

router.get('/api/ssweb', async (req, res, next) => {
      var link = req.query.link
      var apikey = req.query.apikey;
if(!apikey)return res.json({status:false,message:'- CadÃª o parÃ¢metro apikey?'})
      if(!link)return res.json({status:false, motivo:'CadÃª o parÃ¢metro link?'})
if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
RegisKey(apikey, req);
	if(key.map(i => i.apikey)?.includes(apikey)){    
matheusapiblk.ssweb(link).then((data) => { 
		if (!data) return res.json({erro: `ERROR 404`})
		res.set({'Content-Type': 'image/png'})
		res.send(data) 
		}).catch(e => {
         	res.json({erro:'Erro no Servidor Interno'})
})
} else {
  res.json({erro:'Erro no Servidor Interno'})
}
})

/*app.get('/api/ia/bard', async(req, res, next) => {
var { query, url, apikey } = req.query
if(!query) return res.json({status:false, motivo:'CadÃª o parÃ¢metro query?'})
if(!apikey) return res.json({status:false,message:'- CadÃª o parÃ¢metro apikey?'})
if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
RegisKey(apikey, req);
try {
if(!url) { ABC = await fetchJson(`https://apis.ninjaspmc.com.br/ia/gemini/text?query=${query}&token=tokenfree`)
} else { ABC = await fetchJson(`https://apis.ninjaspmc.com.br/ia/gemini/image?url=${url}&query=${query}&token=tokenfree`) }
const replyGm = (txt) => {
return txt.replace("pelo Google", "pelo matheuzinho")
}
return res.json({criador: "@m4thxyz_", resultado: ABC.resultado})
} catch (e) {
console.log(e)
return res.json({resultado: 'Erro no Servidor Interno'})
}
})*/

app.get('/api/ia/gemini', async(req, res, next) => {
var { query, url, apikey } = req.query
if(!query) return res.json({status:false, motivo:'CadÃª o parÃ¢metro query?'})
if(!apikey) return res.json({status:false,message:'- CadÃª o parÃ¢metro apikey?'})
if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
RegisKey(apikey, req);
try {
const { GoogleGenerativeAI } = require("@google/generative-ai")
const keygmn = "AIzaSyDp_SU9AAsquBsBmo3tYY2oK2dh2t9kXf4"
const genAI = new GoogleGenerativeAI(keygmn)
const modelText = genAI.getGenerativeModel({model: 'gemini-1.5-flash'})//gemini-pro
const modelImage = genAI.getGenerativeModel({model: 'gemini-pro-vision'})
if(!url) {
var { response } = await modelText.generateContent(`${encodeURIComponent(query)}`)
txt = response.text();
res.json({criador: "@m4thxyz_", resultado: txt})
} else {
migi = await modelImage.generateContent([query, url]);
txt = migi.response.text();
res.json({criador: "@m4thxyz_", resultado: txt})
}
/*const replyGm = (txt) => {
return txt.replace("pelo Google", "pelo matheuzinho")
}*/
//return res.json({criador: "@m4thxyz_", resultado: ABC.resultado})
} catch (e) {
console.log(e)
return res.json({resultado: 'Erro no Servidor Interno'})
}
})

app.get('/api/ia/bing', async(req, res) => {
try {
apikey = req.query.apikey
query = req.query.query
if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
if (!query) return res.json({ status : false,  message : "Cade o parametro query?"}) 
RegisKey(apikey, req);
url = `https://www.bing.com/search?q=${query}&setmkt=pt-BR&PC=EMMX01&form=LWS002&scope=web`;
axios(url).then(response => {
var $ = cheerio.load(response.data);
const Rst = [];
$("div > p").each(function(){
const TTL = $(this).text();
if(TTL.length > 10)
Rst.push({TTL});
});
let bla = ''
for (let i of Rst) {
bla += `${i.TTL.replace(new RegExp("Web", "gi"), "")}\n\n`
}
res.json({resultado: bla})
}).catch(e => {
return res.json({resultado: "Erro, digite algo que queira pesquisar.."})
})
} catch (e) {
return res.json({resultado: `${e}`})
}
})

app.get('/api/ia/gpt', async(req, res, next) => {
apikey = req.query.apikey
query = req.query.query
if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
if (!query) return res.json({ status : false,  message : "Cade o parametro query?"}) 
RegisKey(apikey, req);
try {
ABC = await openai(query)
var replaceGPT = (txt) => {return allReplace(allReplace(allReplace(allReplace(allReplace(allReplace(txt, `por Lann`, `pelo OpenAI`), `BetaBotz-Ai`, `ChatGPT`), `GitHub: [ERLANRAHMAT](https://github.com/ERLANRAHMAT)`, `Google`), `Lann`, `OpenAI`), `GitHub em https://github.com/ERLANRAHMAT`, `Google`), `GitHub: https://github.com/ERLANRAHMAT`, `Google`)}
res.json({criador: `@m4thxyz_`, resultado: replaceGPT(ABC.result)})
} catch(e) { console.log(e)
res.json({resultado: "Sem resposta do servidor..."}) }
})

app.get('/api/ia/luke', async(req, res, next) => {
apikey = req.query.apikey
query = req.query.query
if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
if (!query) return res.json({ status : false,  message : "Cade o parametro query?"}) 
RegisKey(apikey, req);
try {
ABC = await openai(query)
var replaceGPT = (txt) => {return allReplace(allReplace(allReplace(allReplace(txt, `por Lann`, `pelo Matheus`), `BetaBotz-Ai`, `Luke-AI`), `ERLANRAHMAT`, `m4thxyz`), `Lann`, `Matheus`)}
res.json({criador: `@m4thxyz_`, resultado: replaceGPT(ABC.result)})
} catch(e) { console.log(e)
res.json({resultado: "Sem resposta do servidor..."}) }
})

app.get('/api/ia/ocr', async(req, res, next) => {
apikey = req.query.apikey
img = req.query.img
if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
if (!img) return res.json({ status : false,  message : "Cade o parametro img?"}) 
RegisKey(apikey, req);
  if(key.map(i => i.apikey)?.includes(apikey)){
    fetch(encodeURI(`https://api.lolhuman.xyz/api/ocr?apikey=gataDios&img=${img}`))
    .then(response => response.json())
        .then(hasil => {
        var resultado = hasil.result;
             res.json({
                 status: true,
                 resultado
             })
         })
         .catch(e => {
         	res.json({erro:'Erro no Servidor Interno'})
})
} else {
  res.json({erro:'Erro no Servidor Interno'})
}
})

app.get('/api/pesquisa_agora', async(req, res, next) => {
apikey = req.query.apikey
query = req.query.query
if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
if (!query) return res.json({ status : false,  message : "Cade o parametro query?"}) 
RegisKey(apikey, req);
  if(key.map(i => i.apikey)?.includes(apikey)){
    fetch(encodeURI(`https://apis.bronxyshost.com/api-bronxys/pesquisa_agora?pesq=${query}&apikey=sigma22`))
    .then(response => response.json())
        .then(hasil => {
             res.json({
                 status: 200,
                 message: `${hasil.msg}`
             })
         })
         .catch(e => {
         	res.json({erro:'Erro no Servidor Interno'})
})
} else {
  res.json({erro:'Erro no Servidor Interno'})
}
})

app.get('/api/antiporno', async(req, res) => {
var { url, apikey } = req.query
if(!url) return res.json({resultado: `Faltando o parÃ¢metro url`})
if(!apikey) return res.json({resultado: `Faltando o parÃ¢metro apikey`})
if(!key.map(i => i.apikey)?.includes(apikey)) return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
RegisKey(apikey, req);
try {
ABC = await fetchJson(`https://nsfw-demo.sashido.io/api/image/classify?url=`+url)
data = []
for(nsfw of ABC) {
data.push({type: nsfw.className, probability: nsfw.probability, percentage: String(Number(nsfw.probability * 100).toFixed(1)) + `%`})
}
hentai = data.map(i => i.type).indexOf(`Hentai`)
porn = data.map(i => i.type).indexOf(`Porn`)
return res.json({criador: `@m4thxyz_`,
porno: (data[hentai].probability * 100) > 70 || (data[porn].probability * 100) > 55 ? true : false,
resultado: data})
} catch(e) {
console.log(e)
return res.json({resultado: `Erro`})
}
})

app.get('/api/fazernick', async (req, res) => {
apikey = req.query.apikey  
let nome = req.query.nome || res.json({message: 'insira o parÃ¢metro: ?nome='})
if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
RegisKey(apikey, req);
await gerarnick(nome)
.then(nicks => {
res.send(nicks) 
}).catch(e => {
res.json({erro:'Erro no Servidor Interno'})
})
})

app.get('/api/esporte_noticias', async (req, res) => {
var { apikey, esporte } = req.query
DFN_NTC = esporte.toLowerCase().normalize('NFD').replace(/[\u0300-\u036f]/g, "")
if(!JSON.stringify(['futebol', 'basquete', 'volei', 'tenis', 'atletismo', 'natacao', 'ciclismo', 'boxe', 'beisebol', 'judo', 'ginastica-artistica', 'futebol-americano', 'futsal', 'golfe', 'surfe', 'skate', 'formula-1']).includes(DFN_NTC)) return res.json({
    status: 400, 
    message: "De acordo com o esporte selecionado, nÃ£o Ã© possÃ­vel encontrar resultados exatos sobre. Por favor, verifique o tipos disponÃ­veis abaixo para obter resultados exatos sobre o esporte!",
    esportes: ['futebol', 'basquete', 'volei', 'tenis', 'atletismo', 'natacao', 'ciclismo', 'boxe', 'beisebol', 'judo', 'ginastica-artistica', 'futebol-americano', 'futsal', 'golfe', 'surfe', 'skate', 'formula-1']
  })
if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
RegisKey(apikey, req);
getNoticiasEsporte(DFN_NTC)
.then(esporteData => {
res.json({
    status: 200,
    noticia_esporte: esporte,
    resultado: esporteData
 }) 
}).catch(e => {
res.json({erro:'Erro no Servidor Interno'})
})
})

app.get('/api/e-sports_noticias', async (req, res) => {
var { apikey, query } = req.query
if(!JSON.stringify(["esports", "cod", "csgo", "fifa", "fortnite", "freefire", "gamexp", "pes", "pokemon", "rainbow-6", "valorant", "tcg"]).includes(query)) return res.json({
    status: 400, 
    message: "De acordo com o jogo selecionado, nÃ£o Ã© possÃ­vel encontrar resultados exatos sobre. Por favor, verifique o tipos disponÃ­veis abaixo para obter resultados exatos sobre o jogo!",
    jogos: ["esports", "cod", "csgo", "fifa", "fortnite", "freefire", "gamexp", "pes", "pokemon", "rainbow-6", "valorant", "tcg"]
  })
if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
RegisKey(apikey, req);
getNoticiasEsporte(query)
.then(esporteData => {
res.json({
    status: 200,
    jogo_noticia: query,
    resultado: esporteData
 }) 
}).catch(e => {
res.json({erro:'Erro no Servidor Interno'})
})
})

app.get('/api/wikimedia', async (req, res, next) => {
apikey = req.query.apikey
query = req.query.query
if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
if (!query) return res.json({ status : false,  message : "Cade o parametro query?"})
RegisKey(apikey, req);
wikimedia(query)
.then(hasil => {
var resultado = hasil;
res.json({
status: 200,
resultado
})
}).catch(e => {
res.json({erro:'Erro no Servidor Interno'})
})
})

app.get('/api/gimage',(req,res) => {
apikey = req.query.apikey
txt = req.query.txt
if(!txt) return res.json({message: "Faltando o parametro txt"})
if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
RegisKey(apikey, req);
GOOGLE_IMG_SCRAP({
search: txt, query: { EXTENSION: GOOGLE_QUERY.EXTENSION.JPG }, limit: 5, domains: ["alamy.com", "istockphoto.com", "vecteezy.com", "pinterest.com", "google.com"], excludeWords: ["black", "white"], custom: "name=content&name2=content2", safeSearch: false }).then(data => {
res.json(data)
}).catch(e => {
res.json({erro:'Erro no Servidor Interno'})
}) 
})

app.get('/api/googlesrc',(req,res) => {
apikey = req.query.apikey
query = req.query.query
if(!query) return res.json({message: "Faltando o parametro query"})
if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
RegisKey(apikey, req);
GOOGLE_IMG_SCRAP({search: query})
.then(data => {
res.json(data)
}).catch(e => {
res.json({erro:'Erro no Servidor Interno'})
}) 
})

app.get('/api/wattpad',  async (req, res, next) => {
apikey = req.query.apikey
query = req.query.query
if (!query) return res.json({ status : false,  message : "Cade o parametro query?"})
if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
RegisKey(apikey, req);
wattpad(query).then(result => {
res.json({
resultado: result
})
}).catch(e => {
res.json({erro:'Erro no Servidor Interno'})
})
})

app.get('/api/animetv_search',  async (req, res, next) => {
apikey = req.query.apikey
query = req.query.query
if (!query) return res.json({ status : false,  message : "Cade o parametro query?"})
if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
RegisKey(apikey, req);
getInfo.animeTv.search(query).then(result => {
res.json({
status: 200,
resultado: result
})
}).catch(e => {
res.json({erro:'Erro no Servidor Interno'})
})
})

app.get('/api/animetv_list',  async (req, res, next) => {
apikey = req.query.apikey
url = req.query.url
if (!url) return res.json({ status : false,  message : "Cade o parametro url?"})
if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
RegisKey(apikey, req);
getInfo.animeTv.list(url).then(result => {
res.json({
status: 200,
resultado: result
})
}).catch(e => {
res.json({erro:'Erro no Servidor Interno'})
})
})

app.get('/api/operadora',  async (req, res, next) => {
apikey = req.query.apikey
numero = req.query.numero
if (!numero) return res.json({ status : false,  message : "Cade o parametro numero?"})
if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
RegisKey(apikey, req);
getInfo.qualOperadora(numero).then(result => {
res.json({
status: 200,
resultado: result
})
}).catch(e => {
res.json({erro:'Erro no Servidor Interno'})
})
})

app.get('/api/instareels', async (req, res, next) => {
apikey = req.query.apikey
url = req.query.url
if (!url) return res.json({ status : false,  message : "Cade o parametro url?"})
if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
RegisKey(apikey, req);
saveig_reels(url).then(data => {
res.json(data)
}).catch(e => {
res.json({erro:'Erro no Servidor Interno'})
})
})

// LOGOS 2 TEXTO

app.get('/api/ephoto', async(req, res) => {
var { type, text, apikey } = req.query
if(!type) return res.json({status: false, message : "Cade o parametro type?"})
if(!apikey) return res.json({status: false, message : "Cade o parametro apikey?"})
if(!text) return res.json({status: false, message : "Cade o parametro text?"})
if(!key.map(i => i.apikey)?.includes(apikey)) return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
RegisKey(apikey, req);
var img = new Image()
var date = img.getDate()
await img.ephoto(text, {
  type: type,
  headers: {
		"User-agent": img.userAgent(),
		'cookie': `_gid=GA1.2.694836508.${date}; __gads=ID=e77077076c5a18dc-223769e4b3cf00de:T=${date}:RT=${date}:S=ALNI_MZ54A8a-CdUL0GH7R1OPfiwplOIyQ; PHPSESSID=${img.gerarPHPSESSID()}; _ga=GA1.1.170505887.${date}; _ga_SK0KDDQM5P=GS1.1.${date}.2.1.${date}.0`
	}
}).then(async(ep) => {
return res.json({criador: `@m4thxyz_`, status: true, resultado: ep})
}).catch(e => {console.error(e)
return res.json({criador: `@m4thxyz_`, status: false, resultado: `Erro ao gerar a logo`})})
})

app.get('/api/textpro', async(req, res) => {
var { type, text, apikey } = req.query
if(!type) return res.json({status: false, message : "Cade o parametro type?"})
if(!apikey) return res.json({status: false, message : "Cade o parametro apikey?"})
if(!text) return res.json({status: false, message : "Cade o parametro text?"})
if(!key.map(i => i.apikey)?.includes(apikey)) return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
RegisKey(apikey, req);
var img = new Image()
var date = img.getDate()
await img.textpro(text, {
  type: type,
  headers: {
		"User-agent": img.userAgent(),
		'cookie': `_gid=GA1.2.694836508.${date}; __gads=ID=e77077076c5a18dc-223769e4b3cf00de:T=${date}:RT=${date}:S=ALNI_MZ54A8a-CdUL0GH7R1OPfiwplOIyQ; PHPSESSID=${img.gerarPHPSESSID()}; _ga=GA1.1.170505887.${date}; _ga_SK0KDDQM5P=GS1.1.${date}.2.1.${date}.0`
	}
}).then(async(tp) => {
return res.json({criador: `@m4thxyz_`, status: true, resultado: tp})
}).catch(e => {console.error(e)
return res.json({criador: `@m4thxyz_`, status: false, resultado: `Erro ao gerar a logo`})})
})

app.get('/api/protooxy', async(req, res) => {
var { type, text, apikey } = req.query
if(!type) return res.json({status: false, message : "Cade o parametro type?"})
if(!apikey) return res.json({status: false, message : "Cade o parametro apikey?"})
if(!text) return res.json({status: false, message : "Cade o parametro text?"})
if(!key.map(i => i.apikey)?.includes(apikey)) return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
RegisKey(apikey, req);
var img = new Image()
var date = img.getDate()
await img.protooxy(text, {
  type: type,
  headers: {
		"User-agent": img.userAgent(),
		'cookie': `_gid=GA1.2.694836508.${date}; __gads=ID=e77077076c5a18dc-223769e4b3cf00de:T=${date}:RT=${date}:S=ALNI_MZ54A8a-CdUL0GH7R1OPfiwplOIyQ; PHPSESSID=${img.gerarPHPSESSID()}; _ga=GA1.1.170505887.${date}; _ga_SK0KDDQM5P=GS1.1.${date}.2.1.${date}.0`
	}
}).then(async(pt) => {
return res.json({criador: `@m4thxyz_`, status: true, resultado: pt})
}).catch(e => {console.error(e)
return res.json({criador: `@m4thxyz_`, status: false, resultado: `Erro ao gerar a logo`})})
})

// FIM LOGOS

app.get('/api/pokemon-search', async(req, res, next) => {
apikey = req.query.apikey;
name = req.query.name
if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
if (!name) return res.json({ status : false,  message: "Coloque o parametro: name"})
RegisKey(apikey, req);
Pokemon.setLanguage('portuguese');
Pokemon.getPokemon(name).then((data) => { 
res.json(data)
}).catch(e => {
res.json({
message: `Erro no Servidor Interno`
})})})

app.get('/api/nasaphoto', async(req, res, next) => {
 apikey = req.query.apikey;
 data = req.query.data
if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
if (!data) return res.json({ status : false,  message: "Coloque o parametro: data > Exemplo: 19-10-2007"})
RegisKey(apikey, req);
NASA.APOD('DEMO_KEY', `${data}`, false, false).then((data) => {
 res.json(data)
console.log(data)
}).catch(e => {
res.json({
message: `Erro no Servidor Interno`
})})})

app.get('/api/cep', async(req, res, next) => {
apikey = req.query.apikey;
code = req.query.code
if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
if (!code) return res.json({ status : false,  message: "Preencha ou adicione o parÃ¢metro code"})
RegisKey(apikey, req);
await CEP.getAddressByCEP(`${code}`).then((data) => {
res.json(data)
}).catch(e => {
res.json({
message: `Erro no Servidor Interno`
})})})

app.get('/api/instagram', async(req, res, next) => {
apikey = req.query.apikey;
url = req.query.url
if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
if (!url) return res.json({ status : false,  message: "cade o parametro url?"})
RegisKey(apikey, req);
mumaker.instagram(url).then(data => {
res.json({status: true, cÃ³digo: 200, resultado: data})
}).catch(e => {
res.json({status: false, cÃ³digo: 404, message: `Erro no Servidor Interno`})
})
})

app.get('/api/v2/instagram', async(req, res, next) => {
apikey = req.query.apikey;
url = req.query.url
if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
if (!url) return res.json({ status : false,  message: "cade o parametro url?"})
RegisKey(apikey, req);
FongsiDev_Scraper.Instagram(url).then(ABC => {
res.json({resultado: ABC})
}).catch(e => {
console.log(e)
res.json({erro: 404, message: `Erro no Servidor Interno.`})
})
})

app.get('/api/v3/instagram', async(req, res, next) => {
apikey = req.query.apikey;
url = req.query.url
if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
if (!url) return res.json({ status : false,  message: "cade o parametro url?"})
RegisKey(apikey, req);
Instagram.InDownloader(url).then(data => {
res.json({criador: `@m4thxyz_`, resultado: data[0]})
}).catch(e => {
console.log(e)
res.json({status: false, cÃ³digo: 404, message: `Erro no Servidor Interno`})
})
})

 app.get('/youtube/pesquisar', async(req, res, next) => {
apikey = req.query.apikey;
q = req.query.q
 if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
 if (!q) return res.json({ status : false,  message: "Coloque o parametro: q"})
 RegisKey(apikey, req);
 ytSearch2(q).then(result => {
res.json({
status: true,
cÃ³digo: 200,
criador: `${criador}`,
resultado: result
})}).catch(e => {
res.json({
message: `Erro no Servidor Interno`
})})})

app.get('/api/pornhubsrc', async(req, res, next) => {
apikey = req.query.apikey;
q = req.query.q
 if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
 if (!q) return res.json({ status : false,  message: "Coloque o parametro: q"})
 RegisKey(apikey, req);
 pornhubsrc(q).then(resultado => {
res.json({
status: true,
cÃ³digo: 200,
criador: `${criador}`,
resultado: resultado
})}).catch(e => {
res.json({
message: `Erro no Servidor Interno`
})})})

app.get('/download', async(req, res, next) => {
apikey = req.query.apikey;
url = req.query.url
 if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
 if (!url) return res.json({ status : false,  message: "Coloque o parametro: url"})
 RegisKey(apikey, req);
savefrom(url).then(form => {
res.json({
status: true,
criador: `${criador}`,
resultado: form
})}).catch(e => {
res.json({
message: `Erro no Servidor Interno`
})})})

app.get('/download2', async(req, res, next) => {
apikey = req.query.apikey;
url = req.query.url
 if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
 if (!url) return res.json({ status : false,  message: "Coloque o parametro: url"})
 RegisKey(apikey, req);
snapsave(url).then(data => {
res.json({
status: true,
criador: `${criador}`,
result: data
})}).catch(e => {
res.json({
message: `Erro no Servidor Interno: ${e}`
})})})

app.get('/api/uptodown', async(req, res, next) => {
apikey = req.query.apikey;
q = req.query.q
 if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
 if (!q) return res.json({ status : false,  message: "Coloque o parametro: q"})
 RegisKey(apikey, req);
 uptodown(q).then(resultado => {
res.json({
status: true,
cÃ³digo: 200,
criador: `${criador}`,
resultado: resultado
})}).catch(e => {
res.json({
message: `Erro no Servidor Interno`
})})})

router.all('/api/cartoon', async (req, res) => {
apikey = req.query.apikey;
img = req.query.img;
if(!apikey)return res.json({status:false,message:'- CadÃª o parÃ¢metro apikey?'})
if(!img)return res.json({status:false,message:'- CadÃª o parÃ¢metro img?'})
if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
RegisKey(apikey, req);
auu = await Kibar(`https://xzn.wtf/api/aitoonme?url=${img}&apikey=darkzy_7`)
res.json({
status: true,
resultado: {
url_imagem: `${auu.url}`
}
})
})

router.get('/api/emoji/apple', async (req, res, next) => {
apikey = req.query.apikey
if(!apikey)return res.json({status:false,message:'- CadÃª o parÃ¢metro apikey?'})
	if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
RegisKey(apikey, req);
	var emj = req.query.emj	
	if (!emj) return res.json({ status : false, message : "[!] parÃ¢metros de entrada emj"})
	if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
RegisKey(apikey, req);
	emoji.get(emj)
    .then(async emoji => {
	resul = await getBuffer(emoji.images[0].url)
	res.set({'Content-Type': 'image/png'})
	res.send(resul)
	})
	.catch(error => {
		res.json(loghandler.emoji)
	})
})

router.get('/api/emoji/google', async (req, res, next) => {
apikey = req.query.apikey
if(!apikey)return res.json({status:false,message:'- CadÃª o parÃ¢metro apikey?'})
if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
	var emj = req.query.emj
	if (!emj) return res.json({ status : false, message : "[!] parÃ¢metros de entrada  emj"})
	RegisKey(apikey, req);
	emoji.get(emj)
    .then(async emoji => {
	resul = await getBuffer(emoji.images[1].url)
	res.set({'Content-Type': 'image/png'})
	res.send(resul)
	})
	.catch(error => {
		res.json(loghandler.emoji)
	})
})

router.get('/api/emoji/samsung', async (req, res, next) => {
		var emj = req.query.emj
	if (!emj) return res.json({ status : false, message : "[!] parÃ¢metros de entrada  emj"})
apikey = req.query.apikey
if(!apikey)return res.json({status:false,message:'- CadÃª o parÃ¢metro apikey?'})
	if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
RegisKey(apikey, req);
	emoji.get(emj)
    .then(async emoji => {
	resul = await getBuffer(emoji.images[2].url)
	res.set({'Content-Type': 'image/png'})
	res.send(resul)
	})
	.catch(error => {
		res.json(loghandler.emoji)
	})
})


router.get('/api/emoji/microsoft', async (req, res, next) => {
		var emj = req.query.emj
	if (!emj) return res.json({ status : false, message : "[!] parÃ¢metros de entrada  emj"})
		apikey = req.query.apikey
if(!apikey)return res.json({status:false,message:'- CadÃª o parÃ¢metro apikey?'})
	if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
RegisKey(apikey, req);
	emoji.get(emj)
    .then(async emoji => {
	resul = await getBuffer(emoji.images[3].url)
	res.set({'Content-Type': 'image/png'})
	res.send(resul)
	})
	.catch(error => {
		res.json(loghandler.emoji)
	})
})

router.get('/api/emoji/whatsapp', async (req, res, next) => {
	var emj = req.query.emj
	if (!emj) return res.json({ status : false, message : "[!] parÃ¢metros de entrada  emj"})
	apikey = req.query.apikey
if(!apikey)return res.json({status:false,message:'- CadÃª o parÃ¢metro apikey?'})
	if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
RegisKey(apikey, req);
	emoji.get(emj) 
    .then(async emoji => {
	resul = await getBuffer(emoji.images[4].url)
	res.set({'Content-Type': 'image/png'})
	res.send(resul)
	})
	.catch(error => {
		res.json(loghandler.emoji)
	})
})

router.get('/api/emoji/twitter', async (req, res, next) => {
	var emj = req.query.emj
	if (!emj) return res.json({ status : false, message : "[!] parÃ¢metros de entrada  emj"})
		apikey = req.query.apikey
if(!apikey)return res.json({status:false,message:'- CadÃª o parÃ¢metro apikey?'})
	if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
RegisKey(apikey, req);
	emoji.get(emj) 
    .then(async emoji => {
	resul = await getBuffer(emoji.images[5].url)
	res.set({'Content-Type': 'image/png'})
	res.send(resul)
	})
	.catch(error => {
		res.json(loghandler.emoji)
	})
})

router.get('/api/emoji/facebook', async (req, res, next) => {
	var emj = req.query.emj
	if (!emj) return res.json({ status : false, message : "[!] parÃ¢metros de entrada  emj"})
		apikey = req.query.apikey
if(!apikey)return res.json({status:false,message:'- CadÃª o parÃ¢metro apikey?'})
	if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
RegisKey(apikey, req);
	emoji.get(emj) 
    .then(async emoji => {
	resul = await getBuffer(emoji.images[6].url)
	res.set({'Content-Type': 'image/png'})
	res.send(resul)
	})
	.catch(error => {
		res.json(loghandler.emoji)
	})
})

router.get('/api/emoji/skype', async (req, res, next) => {
	var emj = req.query.emj
	if (!emj) return res.json({ status : false, message : "[!] parÃ¢metros de entrada  emj"})
		apikey = req.query.apikey
if(!apikey)return res.json({status:false,message:'- CadÃª o parÃ¢metro apikey?'})
	if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
RegisKey(apikey, req);
	emoji.get(emj) 
    .then(async emoji => {
	resul = await getBuffer(emoji.images[7].url)
	res.set({'Content-Type': 'image/png'})
	res.send(resul)
	})
	.catch(error => {
		res.json(loghandler.emoji)
	})
})

router.get('/api/canvas/musicard', musicard)  
router.get('/api/canvas/comunismo', comunismo)  
router.get('/api/canvas/bolsonaro', bolsonaro) 
router.get('/api/canvas/bnw', bnw) 
router.get('/api/canvas/affect', affect) 
router.get('/api/canvas/blur', blurr) 
router.get('/api/canvas/beautiful', beautiful)   
router.get('/api/canvas/circle', circle) 
router.get('/api/canvas/del', del) 
router.get('/api/canvas/invert', invert) 
router.get('/api/canvas/gay', gay) 
router.get('/api/canvas/lgbt', lgbt) 
router.get('/api/canvas/facepalm', facepalm)    
router.get('/api/canvas/dither', dither) 
router.get('/api/canvas/jail', jail) 
router.get('/api/canvas/magik', magik) 
router.get('/api/canvas/rip', rip)   
router.get('/api/canvas/sepia', sepia) 
router.get('/api/canvas/rotate', rotate) 
router.get('/api/canvas/pixelate', pixelate) 
router.get('/api/canvas/trash', trash) 
router.get('/api/canvas/wasted', wasted)
router.get('/api/canvas/wanted', wanted)
router.get('/api/canvas/bobross', bobross)
router.get('/api/canvas/karaba', bobross)
router.get('/api/canvas/mms', mms)

router.get('/api/happymod', happymodr)

app.get('/about',(req, res) => {
res.json({
status:true,
message:'Projeto em beta'
})
})

app.get('/api/antiporno',async (req,res,next) => {
url = req.query.url
if(!url)return res.json({
status:false,
motivo:'nao_tem_url'
})
apikey = req.query.apikey
if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
RegisKey(apikey, req);
fetch(`https://nsfw-demo.sashido.io/api/image/classify?url=${url}`).then(e => {
res.json(e)
})
})

router.get('/api/screenshotweb', async (req, res, next) => {
url = req.query.url
if(!url)return res.json({status:false, motivo:'CadÃª o parÃ¢metro url?'})
apikey = req.query.apikey
if(!apikey)return res.json({status:false,message:'CadÃª o parÃ¢metro apikey?'})
if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
RegisKey(apikey, req);
	if(key.map(i => i.apikey)?.includes(apikey)){    
    hasil = `https://api.popcat.xyz/screenshot?url=${url}`
	  data = await fetch(hasil).then(v => v.buffer())   
         await fs.writeFileSync(bla + '/assets/asupan.jpg', data)
        res.sendFile(bla + '/assets/asupan.jpg')
         } else {
  res.json({erro:'Erro no Servidor Interno'})
}    
})

router.get('/api/mirella', async (req, res, next) => {
var apikey = req.query.apikey;
if(!apikey)return res.json({status:false,message:'- CadÃª o parÃ¢metro apikey?'})
if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
RegisKey(apikey, req);
	if(key.map(i => i.apikey)?.includes(apikey)){    
    hasil = `https://apirest.gestorvip.com/api/mirella?apikey=Toms123`
	  data = await fetch(hasil).then(v => v.buffer())   
         await fs.writeFileSync(bla+'/assets/asupan.mp4', data)
        res.sendFile(bla+'/assets/asupan.mp4')
         } else {
  res.json({erro:'Erro no Servidor Interno'})
}    
})

app.get('/api/figurinhas', async (req, res) => {
var apikey = req.query.apikey
if(!apikey) return res.json({status:false,message:'- CadÃª o parÃ¢metro apikey?'})
if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
RegisKey(apikey, req);
try {
fig = `${Math.floor(Math.random() * 8051)}`
hasil = `https://raw.githubusercontent.com/badDevelopper/Testfigu/main/fig (${fig}).webp`
	  data = await fetch(hasil).then(v => v.buffer())   
         await fs.writeFileSync(bla+'/assets/stickera.webp', data)
        res.sendFile(bla+'/assets/stickera.webp')
} catch {
return res.json({resposta: ` Erro na resposta do servidor... Chame meu dono matheuzinho`, status: 500 });
}
});

app.get('/api/figurinhas2', async (req, res) => {
var apikey = req.query.apikey
if(!apikey) return res.json({status:false,message:'- CadÃª o parÃ¢metro apikey?'})
if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
RegisKey(apikey, req);
try {
fig = `${Math.floor(Math.random() * 6840)}`
hasil = `https://raw.githubusercontent.com/monarge/figurinhas/master/fig (${fig}).webp`
	  data = await fetch(hasil).then(v => v.buffer())   
         await fs.writeFileSync(bla+'/assets/stickera.webp', data)
        res.sendFile(bla+'/assets/stickera.webp')
} catch {
return res.json({resposta: ` Erro na resposta do servidor... Chame meu dono matheuzinho`, status: 500 });
}
});

router.get('/sticker/figemoji', async (req, res, next) => {
var apikey = req.query.apikey;
if(!apikey)return res.json({status:false,message:'- CadÃª o parÃ¢metro apikey?'})
if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
RegisKey(apikey, req);
	if(key.map(i => i.apikey)?.includes(apikey)){    
var rnd = Math.floor(Math.random() * 102)
hasil = `https://raw.githubusercontent.com/Scheyot2/media/master/packs/emoji/${rnd}.webp`
	  data = await fetch(hasil).then(v => v.buffer())   
         await fs.writeFileSync(bla+'/assets/stickera.webp', data)
        res.sendFile(bla+'/assets/stickera.webp')
         } else {
  res.json({erro:'Erro no Servidor Interno'})
}    
})

router.get('/sticker/figflork', async (req, res, next) => {
var apikey = req.query.apikey;
if(!apikey)return res.json({status:false,message:'- CadÃª o parÃ¢metro apikey?'})
if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
RegisKey(apikey, req);
	if(key.map(i => i.apikey)?.includes(apikey)){    
var rnd = Math.floor(Math.random() * 102)
hasil = `https://raw.githubusercontent.com/Scheyot2/anya-bot/master/Figurinhas/figu_flork/${rnd}.webp`
	  data = await fetch(hasil).then(v => v.buffer())   
         await fs.writeFileSync(bla+'/assets/stickera.webp', data)
        res.sendFile(bla+'/assets/stickera.webp')
         } else {
  res.json({erro:'Erro no Servidor Interno'})
}    
})

router.get('/sticker/figale', async (req, res, next) => {
var apikey = req.query.apikey;
if(!apikey)return res.json({status:false,message:'- CadÃª o parÃ¢metro apikey?'})
if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
RegisKey(apikey, req);
	if(key.map(i => i.apikey)?.includes(apikey)){    
var rnd = Math.floor(Math.random() * 8051)
    hasil = `https://raw.githubusercontent.com/badDevelopper/Testfigu/master/fig (${rnd}).webp`
	  data = await fetch(hasil).then(v => v.buffer())   
         await fs.writeFileSync(bla+'/assets/stickera.webp', data)
        res.sendFile(bla+'/assets/stickera.webp')
         } else {
  res.json({erro:'Erro no Servidor Interno'})
}    
})

router.get('/sticker/figmemes', async (req, res, next) => {
var apikey = req.query.apikey;
if(!apikey)return res.json({status:false,message:'- CadÃª o parÃ¢metro apikey?'})
if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
RegisKey(apikey, req);
	if(key.map(i => i.apikey)?.includes(apikey)){    
var rnd = Math.floor(Math.random() * 109)
    hasil = `https://raw.githubusercontent.com/Scheyot2/media/master/packs/meme/${rnd}.webp`
	  data = await fetch(hasil).then(v => v.buffer())   
         await fs.writeFileSync(bla+'/assets/stickera.webp', data)
        res.sendFile(bla+'/assets/stickera.webp')
         } else {
  res.json({erro:'Erro no Servidor Interno'})
}    
})

router.get('/sticker/figanime', async (req, res, next) => {
var apikey = req.query.apikey;
if(!apikey)return res.json({status:false,message:'- CadÃª o parÃ¢metro apikey?'})
if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
RegisKey(apikey, req);
	if(key.map(i => i.apikey)?.includes(apikey)){    
var rnd = Math.floor(Math.random() * 109)
    hasil = `https://raw.githubusercontent.com/Scheyot2/media/master/packs/anime/${rnd}.webp`
	  data = await fetch(hasil).then(v => v.buffer())   
         await fs.writeFileSync(bla+'/assets/stickera.webp', data)
        res.sendFile(bla+'/assets/stickera.webp')
         } else {
  res.json({erro:'Erro no Servidor Interno'})
}    
})

router.get('/sticker/figcoreana', async (req, res, next) => {
var apikey = req.query.apikey;
if(!apikey)return res.json({status:false,message:'- CadÃª o parÃ¢metro apikey?'})
if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
RegisKey(apikey, req);
	if(key.map(i => i.apikey)?.includes(apikey)){    
var rnd = Math.floor(Math.random() * 43)
    hasil = `https://raw.githubusercontent.com/Scheyot2/media/master/packs/coreana/${rnd}.webp`
	  data = await fetch(hasil).then(v => v.buffer())   
         await fs.writeFileSync(bla+'/assets/stickera.webp', data)
        res.sendFile(bla+'/assets/stickera.webp')
         } else {
  res.json({erro:'Erro no Servidor Interno'})
}    
})

router.get('/sticker/figbebe', async (req, res, next) => {
var apikey = req.query.apikey;
if(!apikey)return res.json({status:false,message:'- CadÃª o parÃ¢metro apikey?'})
if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
RegisKey(apikey, req);
	if(key.map(i => i.apikey)?.includes(apikey)){    
var rnd = Math.floor(Math.random() * 17)
    hasil = `https://raw.githubusercontent.com/badDevelopper/Apis/master/pack/figbebe/${rnd}.webp`
	  data = await fetch(hasil).then(v => v.buffer())   
         await fs.writeFileSync(bla+'/assets/stickera.webp', data)
        res.sendFile(bla+'/assets/stickera.webp')
         } else {
  res.json({erro:'Erro no Servidor Interno'})
}    
})

router.get('/sticker/figdesenho', async (req, res, next) => {
var apikey = req.query.apikey;
if(!apikey)return res.json({status:false,message:'- CadÃª o parÃ¢metro apikey?'})
if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
RegisKey(apikey, req);
	if(key.map(i => i.apikey)?.includes(apikey)){    
var rnd = Math.floor(Math.random() * 109)
    hasil = `https://raw.githubusercontent.com/Scheyot2/media/master/packs/desenho/${rnd}.webp`
	  data = await fetch(hasil).then(v => v.buffer())   
         await fs.writeFileSync(bla+'/assets/stickera.webp', data)
        res.sendFile(bla+'/assets/stickera.webp')
         } else {
  res.json({erro:'Erro no Servidor Interno'})
}    
})

router.get('/sticker/figanimais', async (req, res, next) => {
var apikey = req.query.apikey;
if(!apikey)return res.json({status:false,message:'- CadÃª o parÃ¢metro apikey?'})
if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
RegisKey(apikey, req);
	if(key.map(i => i.apikey)?.includes(apikey)){    
var rnd = Math.floor(Math.random() * 46)
    hasil = `https://raw.githubusercontent.com/badDevelopper/Apis/master/pack/figanimais/${rnd}.webp`
	  data = await fetch(hasil).then(v => v.buffer())   
         await fs.writeFileSync(bla+'/assets/stickera.webp', data)
        res.sendFile(bla+'/assets/stickera.webp')
         } else {
  res.json({erro:'Erro no Servidor Interno'})
}    
})

router.get('/sticker/figengracada', async (req, res, next) => {
var apikey = req.query.apikey;
if(!apikey)return res.json({status:false,message:'- CadÃª o parÃ¢metro apikey?'})
if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
RegisKey(apikey, req);
	if(key.map(i => i.apikey)?.includes(apikey)){    
var rnd = Math.floor(Math.random() * 25)
    hasil = `https://raw.githubusercontent.com/Scheyot2/media/master/packs/engracadas/${rnd}.webp`
	  data = await fetch(hasil).then(v => v.buffer())   
         await fs.writeFileSync(bla+'/assets/stickera.webp', data)
        res.sendFile(bla+'/assets/stickera.webp')
         } else {
  res.json({erro:'Erro no Servidor Interno'})
}    
})

router.get('/sticker/figraiva', async (req, res, next) => {
var apikey = req.query.apikey;
if(!apikey)return res.json({status:false,message:'- CadÃª o parÃ¢metro apikey?'})
if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
RegisKey(apikey, req);
	if(key.map(i => i.apikey)?.includes(apikey)){    
var rnd = Math.floor(Math.random() * 29)
    hasil = `https://raw.githubusercontent.com/Scheyot2/media/master/packs/raiva/${rnd}.webp`
	  data = await fetch(hasil).then(v => v.buffer())   
         await fs.writeFileSync(bla+'/assets/stickera.webp', data)
        res.sendFile(bla+'/assets/stickera.webp')
         } else {
  res.json({erro:'Erro no Servidor Interno'})
}    
})

router.get('/sticker/figroblox', async (req, res, next) => {
var apikey = req.query.apikey;
if(!apikey)return res.json({status:false,message:'- CadÃª o parÃ¢metro apikey?'})
if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
RegisKey(apikey, req);
	if(key.map(i => i.apikey)?.includes(apikey)){    
var rnd = Math.floor(Math.random() * 21)
    hasil = `https://raw.githubusercontent.com/Scheyot2/media/master/packs/roblox/${rnd}.webp`
	  data = await fetch(hasil).then(v => v.buffer())   
         await fs.writeFileSync(bla+'/assets/stickera.webp', data)
        res.sendFile(bla+'/assets/stickera.webp')
         } else {
  res.json({erro:'Erro no Servidor Interno'})
}    
})

router.get('/nsfw/ahegao', async (req, res, next) => {
      var apikey = req.query.apikey;
if(!apikey)return res.json({status:false,message:'- CadÃª o parÃ¢metro apikey?'})
if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
RegisKey(apikey, req);
	if(key.map(i => i.apikey)?.includes(apikey)){    

    const ahegao = JSON.parse(fs.readFileSync(bla + '/base de dados/random/ANIMES-HENTAI/ahegao.json'));
    const randahegao = ahegao[Math.floor(Math.random() * ahegao.length)];
    data = await fetch(randahegao).then(v => v.buffer())
    await fs.writeFileSync(bla + '/assets/ahegao.jpeg', data)
    res.sendFile(bla + '/assets/ahegao.jpeg')
  } else {
  res.json({erro:'Erro no Servidor Interno'})
  }
})

router.get('/nsfw/ass', async (req, res, next) => {
      var apikey = req.query.apikey;
if(!apikey)return res.json({status:false,message:'- CadÃª o parÃ¢metro apikey?'})
if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
RegisKey(apikey, req);
	if(key.map(i => i.apikey)?.includes(apikey)){    

    const ass = JSON.parse(fs.readFileSync(bla + '/base de dados/random/ANIMES-HENTAI/ass.json'));
    const randass = ass[Math.floor(Math.random() * ass.length)];
    data = await fetch(randass).then(v => v.buffer())
    await fs.writeFileSync(bla + '/assets/ass.jpeg', data)
    res.sendFile(bla + '/assets/ass.jpeg')
  } else {
  res.json({erro:'Erro no Servidor Interno'})
  }
})

router.get('/nsfw/bdsm', async (req, res, next) => {
      var apikey = req.query.apikey;
if(!apikey)return res.json({status:false,message:'- CadÃª o parÃ¢metro apikey?'})
if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
RegisKey(apikey, req);
	if(key.map(i => i.apikey)?.includes(apikey)){    

    const bdsm = JSON.parse(fs.readFileSync(bla + '/base de dados/random/ANIMES-HENTAI/bdsm.json'));
    const randbdsm = bdsm[Math.floor(Math.random() * bdsm.length)];
    data = await fetch(randbdsm).then(v => v.buffer())
    await fs.writeFileSync(bla + '/assets/bdsm.jpeg', data)
    res.sendFile(bla + '/assets/bdsm.jpeg')
  } else {
  res.json({erro:'Erro no Servidor Interno'})
  }
})

router.get('/nsfw/blowjob', async (req, res, next) => {
      var apikey = req.query.apikey;
if(!apikey)return res.json({status:false,message:'- CadÃª o parÃ¢metro apikey?'})
if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
RegisKey(apikey, req);
	if(key.map(i => i.apikey)?.includes(apikey)){    

    const blowjob = JSON.parse(fs.readFileSync(bla + '/base de dados/random/ANIMES-HENTAI/blowjob.json'));
    const randblowjob = blowjob[Math.floor(Math.random() * blowjob.length)];
    data = await fetch(randblowjob).then(v => v.buffer())
    await fs.writeFileSync(bla + '/assets/blowjob.jpeg', data)
    res.sendFile(bla + '/assets/blowjob.jpeg')
  } else {
  res.json({erro:'Erro no Servidor Interno'})
  }
})

router.get('/nsfw/cuckold', async (req, res, next) => {
      var apikey = req.query.apikey;
if(!apikey)return res.json({status:false,message:'- CadÃª o parÃ¢metro apikey?'})
if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
RegisKey(apikey, req);
	if(key.map(i => i.apikey)?.includes(apikey)){    

    const cuckold = JSON.parse(fs.readFileSync(bla + '/base de dados/random/ANIMES-HENTAI/cuckold.json'));
    const randcuckold = cuckold[Math.floor(Math.random() * cuckold.length)];
    data = await fetch(randcuckold).then(v => v.buffer())
    await fs.writeFileSync(bla + '/assets/cuckold.jpeg', data)
    res.sendFile(bla + '/assets/cuckold.jpeg')
  } else {
  res.json({erro:'Erro no Servidor Interno'})
  }
})

router.get('/nsfw/cum', async (req, res, next) => {
      var apikey = req.query.apikey;
if(!apikey)return res.json({status:false,message:'- CadÃª o parÃ¢metro apikey?'})
if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
RegisKey(apikey, req);
	if(key.map(i => i.apikey)?.includes(apikey)){    

    const cum = JSON.parse(fs.readFileSync(bla + '/base de dados/random/ANIMES-HENTAI/cum.json'));
    const randcum = cum[Math.floor(Math.random() * cum.length)];
    data = await fetch(randcum).then(v => v.buffer())
    await fs.writeFileSync(bla + '/assets/cum.jpeg', data)
    res.sendFile(bla + '/assets/cum.jpeg')
  } else {
  res.json({erro:'Erro no Servidor Interno'})
  }
})

router.get('/nsfw/ero', async (req, res, next) => {
      var apikey = req.query.apikey;
if(!apikey)return res.json({status:false,message:'- CadÃª o parÃ¢metro apikey?'})
if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
RegisKey(apikey, req);
	if(key.map(i => i.apikey)?.includes(apikey)){    

    const ero = JSON.parse(fs.readFileSync(bla + '/base de dados/random/ANIMES-HENTAI/ero.json'));
    const randero = ero[Math.floor(Math.random() * ero.length)];
    data = await fetch(randero).then(v => v.buffer())
    await fs.writeFileSync(bla + '/assets/ero.jpeg', data)
    res.sendFile(bla + '/assets/ero.jpeg')
  } else {
  res.json({erro:'Erro no Servidor Interno'})
  }
})

router.get('/nsfw/femdom', async (req, res, next) => {
      var apikey = req.query.apikey;
if(!apikey)return res.json({status:false,message:'- CadÃª o parÃ¢metro apikey?'})
if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
RegisKey(apikey, req);
	if(key.map(i => i.apikey)?.includes(apikey)){    

    const femdom = JSON.parse(fs.readFileSync(bla + '/base de dados/random/ANIMES-HENTAI/femdom.json'));
    const randfemdom = femdom[Math.floor(Math.random() * femdom.length)];
    data = await fetch(randfemdom).then(v => v.buffer())
    await fs.writeFileSync(bla + '/assets/femdom.jpeg', data)
    res.sendFile(bla + '/assets/femdom.jpeg')
  } else {
  res.json({erro:'Erro no Servidor Interno'})
  }
})

router.get('/nsfw/foot', async (req, res, next) => {
      var apikey = req.query.apikey;
if(!apikey)return res.json({status:false,message:'- CadÃª o parÃ¢metro apikey?'})
if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
RegisKey(apikey, req);
	if(key.map(i => i.apikey)?.includes(apikey)){    

    const foot = JSON.parse(fs.readFileSync(bla + '/base de dados/random/ANIMES-HENTAI/foot.json'));
    const randfoot = foot[Math.floor(Math.random() * foot.length)];
    data = await fetch(randfoot).then(v => v.buffer())
    await fs.writeFileSync(bla + '/assets/foot.jpeg', data)
    res.sendFile(bla + '/assets/foot.jpeg')
  } else {
  res.json({erro:'Erro no Servidor Interno'})
  }
})

router.get('/nsfw/gangbang', async (req, res, next) => {
      var apikey = req.query.apikey;
if(!apikey)return res.json({status:false,message:'- CadÃª o parÃ¢metro apikey?'})
if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
RegisKey(apikey, req);
	if(key.map(i => i.apikey)?.includes(apikey)){    

    const gangbang = JSON.parse(fs.readFileSync(bla + '/base de dados/random/ANIMES-HENTAI/gangbang.json'));
    const randgangbang = gangbang[Math.floor(Math.random() * gangbang.length)];
    data = await fetch(randgangbang).then(v => v.buffer())
    await fs.writeFileSync(bla + '/assets/gangbang.jpg', data)
    res.sendFile(bla + '/assets/gangbang.jpg')
  } else {
  res.json({erro:'Erro no Servidor Interno'})
  }
})

router.get('/nsfw/glasses', async (req, res, next) => {
      var apikey = req.query.apikey;
if(!apikey)return res.json({status:false,message:'- CadÃª o parÃ¢metro apikey?'})
if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
RegisKey(apikey, req);
	if(key.map(i => i.apikey)?.includes(apikey)){    

    const glasses = JSON.parse(fs.readFileSync(bla + '/base de dados/random/ANIMES-HENTAI/glasses.json'));
    const randglasses = glasses[Math.floor(Math.random() * glasses.length)];
    data = await fetch(randglasses).then(v => v.buffer())
    await fs.writeFileSync(bla + '/assets/glasses.jpeg', data)
    res.sendFile(bla + '/assets/glasses.jpeg')
  } else {
  res.json({erro:'Erro no Servidor Interno'})
  }
})

router.get('/nsfw/hentai', async (req, res, next) => {
      var apikey = req.query.apikey;
if(!apikey)return res.json({status:false,message:'- CadÃª o parÃ¢metro apikey?'})
if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
RegisKey(apikey, req);
	if(key.map(i => i.apikey)?.includes(apikey)){    

    const hentai = JSON.parse(fs.readFileSync(bla + '/base de dados/random/ANIMES-HENTAI/hentai.json'));
    const randhentai = hentai[Math.floor(Math.random() * hentai.length)];
    data = await fetch(randhentai).then(v => v.buffer())
    await fs.writeFileSync(bla + '/assets/hentai.jpeg', data)
    res.sendFile(bla + '/assets/hentai.jpeg')
  } else {
  res.json({erro:'Erro no Servidor Interno'})
  }
})

router.get('/nsfw/gifs', async (req, res, next) => {
      var apikey = req.query.apikey;
if(!apikey)return res.json({status:false,message:'- CadÃª o parÃ¢metro apikey?'})
if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
RegisKey(apikey, req);
	if(key.map(i => i.apikey)?.includes(apikey)){    
    const gifs = JSON.parse(fs.readFileSync(bla + '/base de dados/random/ANIMES-HENTAI/gifs.json'));
    const randgifs = gifs[Math.floor(Math.random() * gifs.length)];
    data = await fetch(randgifs).then(v => v.buffer())
    await fs.writeFileSync(bla + '/assets/gifs.jpeg', data)
    res.sendFile(bla + '/assets/gifs.jpeg')
  } else {
  res.json({erro:'Erro no Servidor Interno'})
  }
})

router.get('/figu', async (req, res, next) => {
      var apikey = req.query.apikey;
if(!apikey)return res.json({status:false,message:'- CadÃª o parÃ¢metro apikey?'})
if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
RegisKey(apikey, req);
	if(key.map(i => i.apikey)?.includes(apikey)){    
    const gifs = JSON.parse(fs.readFileSync(bla + '/base de dados/figurinhas.json'));
    const randgifs = gifs[Math.floor(Math.random() * gifs.length)];
    data = await fetch(randgifs).then(v => v.buffer())
    await fs.writeFileSync(bla + '/assets/stickera.webp', data)
    res.sendFile(bla + '/assets/stickera.webp')
  } else {
  res.json({erro:'Erro no Servidor Interno'})
  }
})

router.get('/api/stickera', async (req, res, next) => {
      var apikey = req.query.apikey;
if(!apikey)return res.json({status:false,message:'- CadÃª o parÃ¢metro apikey?'})
if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
RegisKey(apikey, req);
	if(key.map(i => i.apikey)?.includes(apikey)){    
    const gifs = JSON.parse(fs.readFileSync(bla + '/base de dados/figurinhas.json'));
    const randgifs = gifs[Math.floor(Math.random() * gifs.length)];
    data = await fetch(randgifs).then(v => v.buffer())
    await fs.writeFileSync(bla + '/assets/stickera.webp', data)
    res.sendFile(bla + '/assets/stickera.webp')
  } else {
  res.json({erro:'Erro no Servidor Interno'})
  }
})

router.get('/nsfw/jahy', async (req, res, next) => {
      var apikey = req.query.apikey;
if(!apikey)return res.json({status:false,message:'- CadÃª o parÃ¢metro apikey?'})
if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
RegisKey(apikey, req);
	if(key.map(i => i.apikey)?.includes(apikey)){    

    const jahy = JSON.parse(fs.readFileSync(bla + '/base de dados/random/ANIMES-HENTAI/jahy.json'));
    const randjahy = jahy[Math.floor(Math.random() * jahy.length)];
    data = await fetch(randjahy).then(v => v.buffer())
    await fs.writeFileSync(bla + '/assets/jahy.jpeg', data)
    res.sendFile(bla + '/assets/jahy.jpeg')
  } else {
  res.json({erro:'Erro no Servidor Interno'})
  }
})

router.get('/nsfw/manga', async (req, res, next) => {
      var apikey = req.query.apikey;
if(!apikey)return res.json({status:false,message:'- CadÃª o parÃ¢metro apikey?'})
if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
RegisKey(apikey, req);
	if(key.map(i => i.apikey)?.includes(apikey)){    

    const manga = JSON.parse(fs.readFileSync(bla + '/base de dados/random/ANIMES-HENTAI/manga.json'));
    const randmanga = manga[Math.floor(Math.random() * manga.length)];
    data = await fetch(randmanga).then(v => v.buffer())
    await fs.writeFileSync(bla + '/assets/manga.jpeg', data)
    res.sendFile(bla + '/assets/manga.jpeg')
  } else {
  res.json({erro:'Erro no Servidor Interno'})
  }
})

router.get('/nsfw/masturbation', async (req, res, next) => {
      var apikey = req.query.apikey;
if(!apikey)return res.json({status:false,message:'- CadÃª o parÃ¢metro apikey?'})
if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
RegisKey(apikey, req);
	if(key.map(i => i.apikey)?.includes(apikey)){    

    const masturbation = JSON.parse(fs.readFileSync(bla + '/base de dados/random/ANIMES-HENTAI/masturbation.json'));
    const randmasturbation = masturbation[Math.floor(Math.random() * masturbation.length)];
    data = await fetch(randmasturbation).then(v => v.buffer())
    await fs.writeFileSync(bla + '/assets/masturbation.jpeg', data)
    res.sendFile(bla + '/assets/masturbation.jpeg')
  } else {
  res.json({erro:'Erro no Servidor Interno'})
  }
})

router.get('/nsfw/neko', async (req, res, next) => {
      var apikey = req.query.apikey;
if(!apikey)return res.json({status:false,message:'- CadÃª o parÃ¢metro apikey?'})
if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
RegisKey(apikey, req);
	if(key.map(i => i.apikey)?.includes(apikey)){    

    const neko = JSON.parse(fs.readFileSync(bla + '/base de dados/random/ANIMES-HENTAI/neko.json'));
    const randneko = neko[Math.floor(Math.random() * neko.length)];
    data = await fetch(randneko).then(v => v.buffer())
    await fs.writeFileSync(bla + '/assets/neko.jpeg', data)
    res.sendFile(bla + '/assets/neko.jpeg')
  } else {
  res.json({erro:'Erro no Servidor Interno'})
  }
})

router.get('/nsfw/orgy', async (req, res, next) => {
      var apikey = req.query.apikey;
if(!apikey)return res.json({status:false,message:'- CadÃª o parÃ¢metro apikey?'})
if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
RegisKey(apikey, req);
	if(key.map(i => i.apikey)?.includes(apikey)){    

    const orgy = JSON.parse(fs.readFileSync(bla + '/base de dados/random/ANIMES-HENTAI/orgy.json'));
    const randorgy = orgy[Math.floor(Math.random() * orgy.length)];
    data = await fetch(randorgy).then(v => v.buffer())
    await fs.writeFileSync(bla + '/assets/orgy.jpeg', data)
    res.sendFile(bla + '/assets/orgy.jpeg')
  } else {
  res.json({erro:'Erro no Servidor Interno'})
  }
})

router.get('/nsfw/panties', async (req, res, next) => {
      var apikey = req.query.apikey;
if(!apikey)return res.json({status:false,message:'- CadÃª o parÃ¢metro apikey?'})
if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
RegisKey(apikey, req);
	if(key.map(i => i.apikey)?.includes(apikey)){    

    const panties = JSON.parse(fs.readFileSync(bla + '/base de dados/random/ANIMES-HENTAI/panties.json'));
    const randpanties = panties[Math.floor(Math.random() * panties.length)];
    data = await fetch(randpanties).then(v => v.buffer())
    await fs.writeFileSync(bla + '/assets/panties.jpeg', data)
    res.sendFile(bla + '/assets/panties.jpeg')
  } else {
  res.json({erro:'Erro no Servidor Interno'})
  }
})

router.get('/nsfw/pussy', async (req, res, next) => {
      var apikey = req.query.apikey;
if(!apikey)return res.json({status:false,message:'- CadÃª o parÃ¢metro apikey?'})
if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
RegisKey(apikey, req);
	if(key.map(i => i.apikey)?.includes(apikey)){    

    const pussy = JSON.parse(fs.readFileSync(bla + '/base de dados/random/ANIMES-HENTAI/pussy.json'));
    const randpussy = pussy[Math.floor(Math.random() * pussy.length)];
    data = await fetch(randpussy).then(v => v.buffer())
    await fs.writeFileSync(bla + '/assets/pussy.jpeg', data)
    res.sendFile(bla + '/assets/pussy.jpeg')
  } else {
  res.json({erro:'Erro no Servidor Interno'})
  }
})

router.get('/nsfw/neko2', async (req, res, next) => {
      var apikey = req.query.apikey;
if(!apikey)return res.json({status:false,message:'- CadÃª o parÃ¢metro apikey?'})
if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
RegisKey(apikey, req);
	if(key.map(i => i.apikey)?.includes(apikey)){    

    const neko2 = JSON.parse(fs.readFileSync(bla + '/base de dados/random/ANIMES-HENTAI/neko2.json'));
    const randneko2 = neko2[Math.floor(Math.random() * neko2.length)];
    data = await fetch(randneko2).then(v => v.buffer())
    await fs.writeFileSync(bla + '/assets/neko2.jpeg', data)
    res.sendFile(bla + '/assets/neko2.jpeg')
  } else {
  res.json({erro:'Erro no Servidor Interno'})
  }
})

router.get('/nsfw/tentacles', async (req, res, next) => {
      var apikey = req.query.apikey;
if(!apikey)return res.json({status:false,message:'- CadÃª o parÃ¢metro apikey?'})
if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
RegisKey(apikey, req);
	if(key.map(i => i.apikey)?.includes(apikey)){    

    const tentacles = JSON.parse(fs.readFileSync(bla + '/base de dados/random/ANIMES-HENTAI/tentacles.json'));
    const randtentacles = tentacles[Math.floor(Math.random() * tentacles.length)];
    data = await fetch(randtentacles).then(v => v.buffer())
    await fs.writeFileSync(bla + '/assets/tentacles.jpeg', data)
    res.sendFile(bla + '/assets/tentacles.jpeg')
  } else {
  res.json({erro:'Erro no Servidor Interno'})
  }
})

router.get('/nsfw/thighs', async (req, res, next) => {
      var apikey = req.query.apikey;
if(!apikey)return res.json({status:false,message:'- CadÃª o parÃ¢metro apikey?'})
if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
RegisKey(apikey, req);
	if(key.map(i => i.apikey)?.includes(apikey)){    

    const thighs = JSON.parse(fs.readFileSync(bla + '/base de dados/random/ANIMES-HENTAI/thighs.json'));
    const randthighs = thighs[Math.floor(Math.random() * thighs.length)];
    data = await fetch(randthighs).then(v => v.buffer())
    await fs.writeFileSync(bla + '/assets/thighs.jpeg', data)
    res.sendFile(bla + '/assets/thighs.jpeg')
  } else {
  res.json({erro:'Erro no Servidor Interno'})
  }
})

router.get('/nsfw/yuri', async (req, res, next) => {
      var apikey = req.query.apikey;
if(!apikey)return res.json({status:false,message:'- CadÃª o parÃ¢metro apikey?'})
if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
RegisKey(apikey, req);
	if(key.map(i => i.apikey)?.includes(apikey)){    

    const yuri = JSON.parse(fs.readFileSync(bla + '/base de dados/random/ANIMES-HENTAI/yuri.json'));
    const randyuri = yuri[Math.floor(Math.random() * yuri.length)];
    data = await fetch(randyuri).then(v => v.buffer())
    await fs.writeFileSync(bla + '/assets/yuri.jpeg', data)
    res.sendFile(bla + '/assets/yuri.jpeg')
  } else {
  res.json({erro:'Erro no Servidor Interno'})
  }
})

router.get('/nsfw/zettai', async (req, res, next) => {
      var apikey = req.query.apikey;
if(!apikey)return res.json({status:false,message:'- CadÃª o parÃ¢metro apikey?'})
if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
RegisKey(apikey, req);
	if(key.map(i => i.apikey)?.includes(apikey)){    

    const zettai = JSON.parse(fs.readFileSync(bla + '/base de dados/random/ANIMES-HENTAI/zettai.json'));
    const randzettai = zettai[Math.floor(Math.random() * zettai.length)];
    data = await fetch(randzettai).then(v => v.buffer())
    await fs.writeFileSync(bla + '/assets/zettai.jpeg', data)
    res.sendFile(bla + '/assets/zettai.jpeg')
  } else {
  res.json({erro:'Erro no Servidor Interno'})
  }
})

router.get('/random/keneki', async (req, res, next) => {
      var apikey = req.query.apikey;
if(!apikey)return res.json({status:false,message:'- CadÃª o parÃ¢metro apikey?'})
if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
RegisKey(apikey, req);
	if(key.map(i => i.apikey)?.includes(apikey)){    

    const keneki = JSON.parse(fs.readFileSync(bla + '/base de dados/random/ANIMES-HENTAI/keneki.json'));
    const randkeneki = keneki[Math.floor(Math.random() * keneki.length)];
    data = await fetch(randkeneki).then(v => v.buffer())
    await fs.writeFileSync(bla + '/assets/keneki.jpeg', data)
    res.sendFile(bla + '/assets/keneki.jpeg')
  } else {
  res.json({erro:'Erro no Servidor Interno'})
  }
})

router.get('/random/megumin', async (req, res, next) => {
      var apikey = req.query.apikey;
if(!apikey)return res.json({status:false,message:'- CadÃª o parÃ¢metro apikey?'})
if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
RegisKey(apikey, req);
	if(key.map(i => i.apikey)?.includes(apikey)){    

    const megumin = JSON.parse(fs.readFileSync(bla + '/base de dados/random/ANIMES-HENTAI/megumin.json'));
    const randmegumin = megumin[Math.floor(Math.random() * megumin.length)];
    data = await fetch(randmegumin).then(v => v.buffer())
    await fs.writeFileSync(bla + '/assets/megumin.jpeg', data)
    res.sendFile(bla + '/assets/megumin.jpeg')
  } else {
  res.json({erro:'Erro no Servidor Interno'})
  }
})

router.get('/random/yotsuba', async (req, res, next) => {
      var apikey = req.query.apikey;
if(!apikey)return res.json({status:false,message:'- CadÃª o parÃ¢metro apikey?'})
if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
RegisKey(apikey, req);
	if(key.map(i => i.apikey)?.includes(apikey)){    

    const yotsuba = JSON.parse(fs.readFileSync(bla + '/base de dados/random/ANIMES-HENTAI/yotsuba.json'));
    const randyotsuba = yotsuba[Math.floor(Math.random() * yotsuba.length)];
    data = await fetch(randyotsuba).then(v => v.buffer())
    await fs.writeFileSync(bla + '/assets/yotsuba.jpeg', data)
    res.sendFile(bla + '/assets/yotsuba.jpeg')
  } else {
  res.json({erro:'Erro no Servidor Interno'})
  }
})

router.get('/random/shinomiya', async (req, res, next) => {
      var apikey = req.query.apikey;
if(!apikey)return res.json({status:false,message:'- CadÃª o parÃ¢metro apikey?'})
if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
RegisKey(apikey, req);
	if(key.map(i => i.apikey)?.includes(apikey)){    

    const shinomiya = JSON.parse(fs.readFileSync(bla + '/base de dados/random/ANIMES-HENTAI/shinomiya.json'));
    const randshinomiya = shinomiya[Math.floor(Math.random() * shinomiya.length)];
    data = await fetch(randshinomiya).then(v => v.buffer())
    await fs.writeFileSync(bla + '/assets/shinomiya.jpeg', data)
    res.sendFile(bla + '/assets/shinomiya.jpeg')
  } else {
  res.json({erro:'Erro no Servidor Interno'})
  }
})

router.get('/random/yumeko', async (req, res, next) => {
      var apikey = req.query.apikey;
if(!apikey)return res.json({status:false,message:'- CadÃª o parÃ¢metro apikey?'})
if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
RegisKey(apikey, req);
	if(key.map(i => i.apikey)?.includes(apikey)){    

    const yumeko = JSON.parse(fs.readFileSync(bla + '/base de dados/random/ANIMES-HENTAI/yumeko.json'));
    const randyumeko = yumeko[Math.floor(Math.random() * yumeko.length)];
    data = await fetch(randyumeko).then(v => v.buffer())
    await fs.writeFileSync(bla + '/assets/yumeko.jpeg', data)
    res.sendFile(bla + '/assets/yumeko.jpeg')
  } else {
  res.json({erro:'Erro no Servidor Interno'})
  }
})

router.get('/random/tejina', async (req, res, next) => {
      var apikey = req.query.apikey;
if(!apikey)return res.json({status:false,message:'- CadÃª o parÃ¢metro apikey?'})
if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
RegisKey(apikey, req);
	if(key.map(i => i.apikey)?.includes(apikey)){    

    const tejina = JSON.parse(fs.readFileSync(bla + '/base de dados/random/ANIMES-HENTAI/tejina.json'));
    const randtejina = tejina[Math.floor(Math.random() * tejina.length)];
    data = await fetch(randtejina).then(v => v.buffer())
    await fs.writeFileSync(bla + '/assets/tejina.jpeg', data)
    res.sendFile(bla + '/assets/tejina.jpeg')
  } else {
  res.json({erro:'Erro no Servidor Interno'})
  }
})

router.get('/random/chiho', async (req, res, next) => {
      var apikey = req.query.apikey;
if(!apikey)return res.json({status:false,message:'- CadÃª o parÃ¢metro apikey?'})
if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
RegisKey(apikey, req);
	if(key.map(i => i.apikey)?.includes(apikey)){    

    const chiho = JSON.parse(fs.readFileSync(bla + '/base de dados/random/ANIMES-HENTAI/chiho.json'));
    const randchiho = chiho[Math.floor(Math.random() * chiho.length)];
    data = await fetch(randchiho).then(v => v.buffer())
    await fs.writeFileSync(bla + '/assets/chiho.jpeg', data)
    res.sendFile(bla + '/assets/chiho.jpeg')
  } else {
  res.json({erro:'Erro no Servidor Interno'})
  }
})

router.get('/wallpaper/cyberspace', async (req, res, next) => {
      var apikey = req.query.apikey;
if(!apikey)return res.json({status:false,message:'- CadÃª o parÃ¢metro apikey?'})
if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
RegisKey(apikey, req);
	if(key.map(i => i.apikey)?.includes(apikey)){    

    const cyberspace = JSON.parse(fs.readFileSync(bla + '/base de dados/random/ANIMES-HENTAI/CyberSpace.json'));
    const randcyberspace = cyberspace[Math.floor(Math.random() * cyberspace.length)];
    data = await fetch(randcyberspace).then(v => v.buffer())
    await fs.writeFileSync(bla + '/assets/cyberspace.jpeg', data)
    res.sendFile(bla + '/assets/cyberspace.jpeg')
  } else {
  res.json({erro:'Erro no Servidor Interno'})
  }
})

router.get('/wallpaper/gaming', async (req, res, next) => {
      var apikey = req.query.apikey;
if(!apikey)return res.json({status:false,message:'- CadÃª o parÃ¢metro apikey?'})
if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
RegisKey(apikey, req);
	if(key.map(i => i.apikey)?.includes(apikey)){    

    const gaming = JSON.parse(fs.readFileSync(bla + '/base de dados/random/ANIMES-HENTAI/GameWallp.json'));
    const randgaming = gaming[Math.floor(Math.random() * gaming.length)];
    data = await fetch(randgaming).then(v => v.buffer())
    await fs.writeFileSync(bla + '/assets/gaming.jpeg', data)
    res.sendFile(bla + '/assets/gaming.jpeg')
  } else {
  res.json({erro:'Erro no Servidor Interno'})
  }
})

router.get('/wallpaper/programing', async (req, res, next) => {
      var apikey = req.query.apikey;
if(!apikey)return res.json({status:false,message:'- CadÃª o parÃ¢metro apikey?'})
if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
RegisKey(apikey, req);
	if(key.map(i => i.apikey)?.includes(apikey)){    

    const programing = JSON.parse(fs.readFileSync(bla + '/base de dados/random/ANIMES-HENTAI/Programming.json'));
    const randprograming = programing[Math.floor(Math.random() * programing.length)];
    data = await fetch(randprograming).then(v => v.buffer())
    await fs.writeFileSync(bla + '/assets/programing.jpeg', data)
    res.sendFile(bla + '/assets/programing.jpeg')
  } else {
  res.json({erro:'Erro no Servidor Interno'})
  }
})

router.get('/wallpaper/wallpapertec', async (req, res, next) => {
      var apikey = req.query.apikey;
if(!apikey)return res.json({status:false,message:'- CadÃª o parÃ¢metro apikey?'})
if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
RegisKey(apikey, req);
	if(key.map(i => i.apikey)?.includes(apikey)){    

    const teknologi = JSON.parse(fs.readFileSync(bla + '/base de dados/random/ANIMES-HENTAI/Technology.json'));
    const randteknologi = teknologi[Math.floor(Math.random() * teknologi.length)];
    data = await fetch(randteknologi).then(v => v.buffer())
    await fs.writeFileSync(bla + '/assets/teknologi.jpeg', data)
    res.sendFile(bla + '/assets/teknologi.jpeg')
  } else {
  res.json({erro:'Erro no Servidor Interno'})
  }
})

router.get('/wallpaper/mountain', async (req, res, next) => {
      var apikey = req.query.apikey;
if(!apikey)return res.json({status:false,message:'- CadÃª o parÃ¢metro apikey?'})
if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
RegisKey(apikey, req);
	if(key.map(i => i.apikey)?.includes(apikey)){    

    const mountain = JSON.parse(fs.readFileSync(bla + '/base de dados/random/ANIMES-HENTAI/Mountain.json'));
    const randmountain = mountain[Math.floor(Math.random() * mountain.length)];
    data = await fetch(randmountain).then(v => v.buffer())
    await fs.writeFileSync(bla + '/assets/mountain.jpeg', data)
    res.sendFile(bla + '/assets/mountain.jpeg')
  } else {
  res.json({erro:'Erro no Servidor Interno'})
  }
})



router.get('/random/toukachan', async (req, res, next) => {
      var apikey = req.query.apikey;
if(!apikey)return res.json({status:false,message:'- CadÃª o parÃ¢metro apikey?'})
if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
RegisKey(apikey, req);
	if(key.map(i => i.apikey)?.includes(apikey)){    

    const toukachan = JSON.parse(fs.readFileSync(bla + '/base de dados/random/ANIMES-HENTAI/toukachan.json'));
    const randtoukachan = toukachan[Math.floor(Math.random() * toukachan.length)];
    data = await fetch(randtoukachan).then(v => v.buffer())
    await fs.writeFileSync(bla + '/assets/toukachan.jpeg', data)
    res.sendFile(bla + '/assets/toukachan.jpeg')
  } else {
  res.json({erro:'Erro no Servidor Interno'})
  }
})

router.get('/random/akira', async (req, res, next) => {
      var apikey = req.query.apikey;
if(!apikey)return res.json({status:false,message:'- CadÃª o parÃ¢metro apikey?'})
if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
RegisKey(apikey, req);
	if(key.map(i => i.apikey)?.includes(apikey)){    

    const akira = JSON.parse(fs.readFileSync(bla + '/base de dados/random/ANIMES-HENTAI/akira.json'));
    const randakira = akira[Math.floor(Math.random() * akira.length)];
    data = await fetch(randakira).then(v => v.buffer())
    await fs.writeFileSync(bla + '/assets/akira.jpeg', data)
    res.sendFile(bla + '/assets/akira.jpeg')
  } else {
  res.json({erro:'Erro no Servidor Interno'})
  }
})

router.get('/random/itori', async (req, res, next) => {
      var apikey = req.query.apikey;
if(!apikey)return res.json({status:false,message:'- CadÃª o parÃ¢metro apikey?'})
if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
RegisKey(apikey, req);
	if(key.map(i => i.apikey)?.includes(apikey)){    

    const itori = JSON.parse(fs.readFileSync(bla + '/base de dados/random/ANIMES-HENTAI/itori.json'));
    const randitori = itori[Math.floor(Math.random() * itori.length)];
    data = await fetch(randitori).then(v => v.buffer())
    await fs.writeFileSync(bla + '/assets/itori.jpeg', data)
    res.sendFile(bla + '/assets/itori.jpeg')
  } else {
  res.json({erro:'Erro no Servidor Interno'})
  }
})

router.get('/random/kurumi', async (req, res, next) => {
      var apikey = req.query.apikey;
if(!apikey)return res.json({status:false,message:'- CadÃª o parÃ¢metro apikey?'})
if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
RegisKey(apikey, req);
	if(key.map(i => i.apikey)?.includes(apikey)){    

    const kurumi = JSON.parse(fs.readFileSync(bla + '/base de dados/random/ANIMES-HENTAI/kurumi.json'));
    const randkurumi = kurumi[Math.floor(Math.random() * kurumi.length)];
    data = await fetch(randkurumi).then(v => v.buffer())
    await fs.writeFileSync(bla + '/assets/kurumi.jpeg', data)
    res.sendFile(bla + '/assets/kurumi.jpeg')
  } else {
  res.json({erro:'Erro no Servidor Interno'})
  }
})

router.get('/random/miku', async (req, res, next) => {
      var apikey = req.query.apikey;
if(!apikey)return res.json({status:false,message:'- CadÃª o parÃ¢metro apikey?'})
if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
RegisKey(apikey, req);
	if(key.map(i => i.apikey)?.includes(apikey)){    

    const miku = JSON.parse(fs.readFileSync(bla + '/base de dados/random/ANIMES-HENTAI/miku.json'));
    const randmiku = miku[Math.floor(Math.random() * miku.length)];
    data = await fetch(randmiku).then(v => v.buffer())
    await fs.writeFileSync(bla + '/assets/miku.jpeg', data)
    res.sendFile(bla + '/assets/miku.jpeg')
  } else {
  res.json({erro:'Erro no Servidor Interno'})
  }
})

router.get('/random/pokemon', async (req, res, next) => {
      var apikey = req.query.apikey;
if(!apikey)return res.json({status:false,message:'- CadÃª o parÃ¢metro apikey?'})
if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
RegisKey(apikey, req);
	if(key.map(i => i.apikey)?.includes(apikey)){    

    const pokemon = JSON.parse(fs.readFileSync(bla + '/base de dados/random/ANIMES-HENTAI/pokemon.json'));
    const randpokemon = pokemon[Math.floor(Math.random() * pokemon.length)];
    data = await fetch(randpokemon).then(v => v.buffer())
    await fs.writeFileSync(bla + '/assets/pokemon.jpeg', data)
    res.sendFile(bla + '/assets/pokemon.jpeg')
  } else {
  res.json({erro:'Erro no Servidor Interno'})
  }
})

router.get('/random/ryujin', async (req, res, next) => {
      var apikey = req.query.apikey;
if(!apikey)return res.json({status:false,message:'- CadÃª o parÃ¢metro apikey?'})
if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
RegisKey(apikey, req);
	if(key.map(i => i.apikey)?.includes(apikey)){    

    const ryujin = JSON.parse(fs.readFileSync(bla + '/base de dados/random/ANIMES-HENTAI/ryujin.json'));
    const randryujin = ryujin[Math.floor(Math.random() * ryujin.length)];
    data = await fetch(randryujin).then(v => v.buffer())
    await fs.writeFileSync(bla + '/assets/ryujin.jpeg', data)
    res.sendFile(bla + '/assets/ryujin.jpeg')
  } else {
  res.json({erro:'Erro no Servidor Interno'})
  }
})

router.get('/random/rose', async (req, res, next) => {
      var apikey = req.query.apikey;
if(!apikey)return res.json({status:false,message:'- CadÃª o parÃ¢metro apikey?'})
if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
RegisKey(apikey, req);
	if(key.map(i => i.apikey)?.includes(apikey)){    

    const rose = JSON.parse(fs.readFileSync(bla + '/base de dados/random/ANIMES-HENTAI/rose.json'));
    const randrose = rose[Math.floor(Math.random() * rose.length)];
    data = await fetch(randrose).then(v => v.buffer())
    await fs.writeFileSync(bla + '/assets/rose.jpeg', data)
    res.sendFile(bla + '/assets/rose.jpeg')
  } else {
  res.json({erro:'Erro no Servidor Interno'})
  }
})

router.get('/random/kaori', async (req, res, next) => {
      var apikey = req.query.apikey;
if(!apikey)return res.json({status:false,message:'- CadÃª o parÃ¢metro apikey?'})
if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
RegisKey(apikey, req);
	if(key.map(i => i.apikey)?.includes(apikey)){    

    const kaori = JSON.parse(fs.readFileSync(bla + '/base de dados/random/ANIMES-HENTAI/kaori.json'));
    const randkaori = kaori[Math.floor(Math.random() * kaori.length)];
    data = await fetch(randkaori).then(v => v.buffer())
    await fs.writeFileSync(bla + '/assets/kaori.jpeg', data)
    res.sendFile(bla + '/assets/kaori.jpeg')
  } else {
  res.json({erro:'Erro no Servidor Interno'})
  }
})

router.get('/random/shizuka', async (req, res, next) => {
      var apikey = req.query.apikey;
if(!apikey)return res.json({status:false,message:'- CadÃª o parÃ¢metro apikey?'})
if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
RegisKey(apikey, req);
	if(key.map(i => i.apikey)?.includes(apikey)){    

    const shizuka = JSON.parse(fs.readFileSync(bla + '/base de dados/random/ANIMES-HENTAI/shizuka.json'));
    const randshizuka = shizuka[Math.floor(Math.random() * shizuka.length)];
    data = await fetch(randshizuka).then(v => v.buffer())
    await fs.writeFileSync(bla + '/assets/shizuka.jpeg', data)
    res.sendFile(bla + '/assets/shizuka.jpeg')
  } else {
  res.json({erro:'Erro no Servidor Interno'})
  }
})

router.get('/random/kaga', async (req, res, next) => {
      var apikey = req.query.apikey;
if(!apikey)return res.json({status:false,message:'- CadÃª o parÃ¢metro apikey?'})
if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
RegisKey(apikey, req);
	if(key.map(i => i.apikey)?.includes(apikey)){    

    const kaga = JSON.parse(fs.readFileSync(bla + '/base de dados/random/ANIMES-HENTAI/kaga.json'));
    const randkaga = kaga[Math.floor(Math.random() * kaga.length)];
    data = await fetch(randkaga).then(v => v.buffer())
    await fs.writeFileSync(bla + '/assets/kaga.jpeg', data)
    res.sendFile(bla + '/assets/kaga.jpeg')
  } else {
  res.json({erro:'Erro no Servidor Interno'})
  }
})

router.get('/random/kotori', async (req, res, next) => {
      var apikey = req.query.apikey;
if(!apikey)return res.json({status:false,message:'- CadÃª o parÃ¢metro apikey?'})
if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
RegisKey(apikey, req);
	if(key.map(i => i.apikey)?.includes(apikey)){    

    const kotori = JSON.parse(fs.readFileSync(bla + '/base de dados/random/ANIMES-HENTAI/kotori.json'));
    const randkotori = kotori[Math.floor(Math.random() * kotori.length)];
    data = await fetch(randkotori).then(v => v.buffer())
    await fs.writeFileSync(bla + '/assets/kotori.jpeg', data)
    res.sendFile(bla + '/assets/kotori.jpeg')
  } else {
  res.json({erro:'Erro no Servidor Interno'})
  }
})

router.get('/random/mikasa', async (req, res, next) => {
      var apikey = req.query.apikey;
if(!apikey)return res.json({status:false,message:'- CadÃª o parÃ¢metro apikey?'})
if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
RegisKey(apikey, req);
	if(key.map(i => i.apikey)?.includes(apikey)){    

    const mikasa = JSON.parse(fs.readFileSync(bla + '/base de dados/random/ANIMES-HENTAI/mikasa.json'));
    const randmikasa = mikasa[Math.floor(Math.random() * mikasa.length)];
    data = await fetch(randmikasa).then(v => v.buffer())
    await fs.writeFileSync(bla + '/assets/mikasa.jpeg', data)
    res.sendFile(bla + '/assets/mikasa.jpeg')
  } else {
  res.json({erro:'Erro no Servidor Interno'})
  }
})

router.get('/random/akiyama', async (req, res, next) => {
      var apikey = req.query.apikey;
if(!apikey)return res.json({status:false,message:'- CadÃª o parÃ¢metro apikey?'})
if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
RegisKey(apikey, req);
	if(key.map(i => i.apikey)?.includes(apikey)){    

    const akiyama = JSON.parse(fs.readFileSync(bla + '/base de dados/random/ANIMES-HENTAI/akiyama.json'));
    const randakiyama = akiyama[Math.floor(Math.random() * akiyama.length)];
    data = await fetch(randakiyama).then(v => v.buffer())
    await fs.writeFileSync(bla + '/assets/akiyama.jpeg', data)
    res.sendFile(bla + '/assets/akiyama.jpeg')
  } else {
  res.json({erro:'Erro no Servidor Interno'})
  }
})

router.get('/random/gremory', async (req, res, next) => {
      var apikey = req.query.apikey;
if(!apikey)return res.json({status:false,message:'- CadÃª o parÃ¢metro apikey?'})
if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
RegisKey(apikey, req);
	if(key.map(i => i.apikey)?.includes(apikey)){    

    const gremory = JSON.parse(fs.readFileSync(bla + '/base de dados/random/ANIMES-HENTAI/gremory.json'));
    const randgremory = gremory[Math.floor(Math.random() * gremory.length)];
    data = await fetch(randgremory).then(v => v.buffer())
    await fs.writeFileSync(bla + '/assets/gremory.jpeg', data)
    res.sendFile(bla + '/assets/gremory.jpeg')
  } else {
  res.json({erro:'Erro no Servidor Interno'})
  }
})

router.get('/random/isuzu', async (req, res, next) => {
      var apikey = req.query.apikey;
if(!apikey)return res.json({status:false,message:'- CadÃª o parÃ¢metro apikey?'})
if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
RegisKey(apikey, req);
	if(key.map(i => i.apikey)?.includes(apikey)){    

    const isuzu = JSON.parse(fs.readFileSync(bla + '/base de dados/random/ANIMES-HENTAI/isuzu.json'));
    const randisuzu = isuzu[Math.floor(Math.random() * isuzu.length)];
    data = await fetch(randisuzu).then(v => v.buffer())
    await fs.writeFileSync(bla + '/assets/isuzu.jpeg', data)
    res.sendFile(bla + '/assets/isuzu.jpeg')
  } else {
  res.json({erro:'Erro no Servidor Interno'})
  }
})

router.get('/random/cosplay', async (req, res, next) => {
      var apikey = req.query.apikey;
if(!apikey)return res.json({status:false,message:'- CadÃª o parÃ¢metro apikey?'})
if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
RegisKey(apikey, req);
	if(key.map(i => i.apikey)?.includes(apikey)){    

    const cosplay = JSON.parse(fs.readFileSync(bla + '/base de dados/random/ANIMES-HENTAI/cosplay.json'));
    const randcosplay = cosplay[Math.floor(Math.random() * cosplay.length)];
    data = await fetch(randcosplay).then(v => v.buffer())
    await fs.writeFileSync(bla + '/assets/cosplay.jpeg', data)
    res.sendFile(bla + '/assets/cosplay.jpeg')
  } else {
  res.json({erro:'Erro no Servidor Interno'})
  }
})

router.get('/random/shina', async (req, res, next) => {
      var apikey = req.query.apikey;
if(!apikey)return res.json({status:false,message:'- CadÃª o parÃ¢metro apikey?'})
if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
RegisKey(apikey, req);
	if(key.map(i => i.apikey)?.includes(apikey)){    

    const shina = JSON.parse(fs.readFileSync(bla + '/base de dados/random/ANIMES-HENTAI/shina.json'));
    const randshina = shina[Math.floor(Math.random() * shina.length)];
    data = await fetch(randshina).then(v => v.buffer())
    await fs.writeFileSync(bla + '/assets/shina.jpeg', data)
    res.sendFile(bla + '/assets/shina.jpeg')
  } else {
  res.json({erro:'Erro no Servidor Interno'})
  }
})

router.get('/random/kagura', async (req, res, next) => {
      var apikey = req.query.apikey;
if(!apikey)return res.json({status:false,message:'- CadÃª o parÃ¢metro apikey?'})
if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
RegisKey(apikey, req);
	if(key.map(i => i.apikey)?.includes(apikey)){    

    const kagura = JSON.parse(fs.readFileSync(bla + '/base de dados/random/ANIMES-HENTAI/kagura.json'));
    const randkagura = kagura[Math.floor(Math.random() * kagura.length)];
    data = await fetch(randkagura).then(v => v.buffer())
    await fs.writeFileSync(bla + '/assets/kagura.jpeg', data)
    res.sendFile(bla + '/assets/kagura.jpeg')
  } else {
  res.json({erro:'Erro no Servidor Interno'})
  }
})

router.get('/random/shinka', async (req, res, next) => {
      var apikey = req.query.apikey;
if(!apikey)return res.json({status:false,message:'- CadÃª o parÃ¢metro apikey?'})
if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
RegisKey(apikey, req);
	if(key.map(i => i.apikey)?.includes(apikey)){    

    const shinka = JSON.parse(fs.readFileSync(bla + '/base de dados/random/ANIMES-HENTAI/shinka.json'));
    const randshinka = shinka[Math.floor(Math.random() * shinka.length)];
    data = await fetch(randshinka).then(v => v.buffer())
    await fs.writeFileSync(bla + '/assets/shinka.jpeg', data)
    res.sendFile(bla + '/assets/shinka.jpeg')
  } else {
  res.json({erro:'Erro no Servidor Interno'})
  }
})

router.get('/random/eba', async (req, res, next) => {
      var apikey = req.query.apikey;
if(!apikey)return res.json({status:false,message:'- CadÃª o parÃ¢metro apikey?'})
if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
RegisKey(apikey, req);
	if(key.map(i => i.apikey)?.includes(apikey)){    

    const eba = JSON.parse(fs.readFileSync(bla + '/base de dados/random/ANIMES-HENTAI/eba.json'));
    const randeba = eba[Math.floor(Math.random() * eba.length)];
    data = await fetch(randeba).then(v => v.buffer())
    await fs.writeFileSync(bla + '/assets/eba.jpeg', data)
    res.sendFile(bla + '/assets/eba.jpeg')
  } else {
  res.json({erro:'Erro no Servidor Interno'})
  }
})

router.get('/random/deidara', async (req, res, next) => {
      var apikey = req.query.apikey;
if(!apikey)return res.json({status:false,message:'- CadÃª o parÃ¢metro apikey?'})
if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
RegisKey(apikey, req);
	if(key.map(i => i.apikey)?.includes(apikey)){    

    const Deidara = JSON.parse(fs.readFileSync(bla + '/base de dados/random/ANIMES-HENTAI/deidara.json'));
    const randDeidara = Deidara[Math.floor(Math.random() * Deidara.length)];
    data = await fetch(randDeidara).then(v => v.buffer())
    await fs.writeFileSync(bla + '/assets/deidara.jpeg', data)
    res.sendFile(bla + '/assets/deidara.jpeg')
  } else {
  res.json({erro:'Erro no Servidor Interno'})
  }
})



router.get('/random/jeni', async (req, res, next) => {
      var apikey = req.query.apikey;
if(!apikey)return res.json({status:false,message:'- CadÃª o parÃ¢metro apikey?'})
if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
RegisKey(apikey, req);
	if(key.map(i => i.apikey)?.includes(apikey)){    

    const jeni = JSON.parse(fs.readFileSync(bla + '/base de dados/random/ANIMES-HENTAI/jeni.json'));
    const randjeni = jeni[Math.floor(Math.random() * jeni.length)];
    data = await fetch(randjeni).then(v => v.buffer())
    await fs.writeFileSync(bla + '/assets/jeni.jpeg', data)
    res.sendFile(bla + '/assets/jeni.jpeg')
  } else {
  res.json({erro:'Erro no Servidor Interno'})
  }
})


router.get('/random/meme', async (req, res, next) => {
      var apikey = req.query.apikey;
if(!apikey)return res.json({status:false,message:'- CadÃª o parÃ¢metro apikey?'})
if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
RegisKey(apikey, req);
	if(key.map(i => i.apikey)?.includes(apikey)){    

    const meme = JSON.parse(fs.readFileSync(bla + '/base de dados/random/ANIMES-HENTAI/meme.json'));
    const randmeme = meme[Math.floor(Math.random() * meme.length)];
    data = await fetch(randmeme).then(v => v.buffer())
    await fs.writeFileSync(bla + '/assets/meme.jpeg', data)
    res.sendFile(bla + '/assets/meme.jpeg')
  } else {
  res.json({erro:'Erro no Servidor Interno'})
  }
})

router.get('/wallpaper/satanic', async (req, res, next) => {
      var apikey = req.query.apikey;
if(!apikey)return res.json({status:false,message:'- CadÃª o parÃ¢metro apikey?'})
if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
RegisKey(apikey, req);
	if(key.map(i => i.apikey)?.includes(apikey)){    

    const satanic = JSON.parse(fs.readFileSync(bla + '/base de dados/random/ANIMES-HENTAI/satanic.json'));
    const randsatanic = satanic[Math.floor(Math.random() * satanic.length)];
    data = await fetch(randsatanic).then(v => v.buffer())
    await fs.writeFileSync(bla + '/assets/satanic.jpeg', data)
    res.sendFile(bla + '/assets/satanic.jpeg')
  } else {
  res.json({erro:'Erro no Servidor Interno'})
  }
})



router.get('/random/itachi', async (req, res, next) => {
      var apikey = req.query.apikey;
if(!apikey)return res.json({status:false,message:'- CadÃª o parÃ¢metro apikey?'})
if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
RegisKey(apikey, req);
	if(key.map(i => i.apikey)?.includes(apikey)){    

    const Itachi = JSON.parse(fs.readFileSync(bla + '/base de dados/random/ANIMES-HENTAI/itachi.json'));
    const randItachi = Itachi[Math.floor(Math.random() * Itachi.length)];
    data = await fetch(randItachi).then(v => v.buffer())
    await fs.writeFileSync(bla + '/assets/ita.jpeg', data)
    res.sendFile(bla + '/assets/ita.jpeg')
  } else {
  res.json({erro:'Erro no Servidor Interno'})
  }
})

router.get('/random/madara', async (req, res, next) => {
      var apikey = req.query.apikey;
if(!apikey)return res.json({status:false,message:'- CadÃª o parÃ¢metro apikey?'})
if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
RegisKey(apikey, req);
	if(key.map(i => i.apikey)?.includes(apikey)){    

    const Madara = JSON.parse(fs.readFileSync(bla + '/base de dados/random/ANIMES-HENTAI/madara.json'));
    const randMadara = Madara[Math.floor(Math.random() * Madara.length)];
    data = await fetch(randMadara).then(v => v.buffer())
    await fs.writeFileSync(bla + '/assets/madara.jpeg', data)
    res.sendFile(bla + '/assets/madara.jpeg')
  } else {
  res.json({erro:'Erro no Servidor Interno'})
  }
})

router.get('/random/yuki', async (req, res, next) => {
      var apikey = req.query.apikey;
if(!apikey)return res.json({status:false,message:'- CadÃª o parÃ¢metro apikey?'})
if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
RegisKey(apikey, req);
	if(key.map(i => i.apikey)?.includes(apikey)){    

    const Yuki = JSON.parse(fs.readFileSync(bla + '/base de dados/random/ANIMES-HENTAI/yuki.json'));
    const randYuki = Yuki[Math.floor(Math.random() * Yuki.length)];
    data = await fetch(randYuki).then(v => v.buffer())
    await fs.writeFileSync(bla + '/assets/yuki.jpeg', data)
    res.sendFile(bla + '/assets/yuki.jpeg')
  } else {
  res.json({erro:'Erro no Servidor Interno'})
  }
})

router.get('/wallpaper/asuna', async (req, res, next) => {
      var apikey = req.query.apikey;
if(!apikey)return res.json({status:false,message:'- CadÃª o parÃ¢metro apikey?'})
if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
RegisKey(apikey, req);
	if(key.map(i => i.apikey)?.includes(apikey)){    

    const asuna = JSON.parse(fs.readFileSync(bla + '/base de dados/random/ANIMES-HENTAI/asuna.json'));
    const randasuna = asuna[Math.floor(Math.random() * asuna.length)];
    data = await fetch(randasuna).then(v => v.buffer())
    await fs.writeFileSync(bla + '/assets/asuna.jpeg', data)
    res.sendFile(bla + '/assets/asuna.jpeg')
  } else {
  res.json({erro:'Erro no Servidor Interno'})
  }
})

router.get('/random/ayuzawa', async (req, res, next) => {
      var apikey = req.query.apikey;
if(!apikey)return res.json({status:false,message:'- CadÃª o parÃ¢metro apikey?'})
if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
RegisKey(apikey, req);
	if(key.map(i => i.apikey)?.includes(apikey)){    

    const ayuzawa = JSON.parse(fs.readFileSync(bla + '/base de dados/random/ANIMES-HENTAI/ayuzawa.json'));
    const randayuzawa = ayuzawa[Math.floor(Math.random() * ayuzawa.length)];
    data = await fetch(randayuzawa).then(v => v.buffer())
    await fs.writeFileSync(bla + '/assets/ayuzawa.jpeg', data)
    res.sendFile(bla + '/assets/ayuzawa.jpeg')
  } else {
  res.json({erro:'Erro no Servidor Interno'})
  }
})

router.get('/random/chitoge', async (req, res, next) => {
      var apikey = req.query.apikey;
if(!apikey)return res.json({status:false,message:'- CadÃª o parÃ¢metro apikey?'})
if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
RegisKey(apikey, req);
	if(key.map(i => i.apikey)?.includes(apikey)){    

    const chitoge = JSON.parse(fs.readFileSync(bla + '/base de dados/random/ANIMES-HENTAI/chitoge.json'));
    const randchitoge = chitoge[Math.floor(Math.random() * chitoge.length)];
    data = await fetch(randchitoge).then(v => v.buffer())
    await fs.writeFileSync(bla + '/assets/chitoge.jpeg', data)
    res.sendFile(bla + '/assets/chitoge.jpeg')
  } else {
  res.json({erro:'Erro no Servidor Interno'})
  }
})

router.get('/random/emilia', async (req, res, next) => {
      var apikey = req.query.apikey;
if(!apikey)return res.json({status:false,message:'- CadÃª o parÃ¢metro apikey?'})
if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
RegisKey(apikey, req);
	if(key.map(i => i.apikey)?.includes(apikey)){    

    const emilia = JSON.parse(fs.readFileSync(bla + '/base de dados/random/ANIMES-HENTAI/emilia.json'));
    const randemilia = emilia[Math.floor(Math.random() * emilia.length)];
    data = await fetch(randemilia).then(v => v.buffer())
    await fs.writeFileSync(bla + '/assets/emilia.jpeg', data)
    res.sendFile(bla + '/assets/emilia.jpeg')
  } else {
  res.json({erro:'Erro no Servidor Interno'})
  }
})

router.get('/random/hestia', async (req, res, next) => {
      var apikey = req.query.apikey;
if(!apikey)return res.json({status:false,message:'- CadÃª o parÃ¢metro apikey?'})
if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
RegisKey(apikey, req);
	if(key.map(i => i.apikey)?.includes(apikey)){    

    const hestia = JSON.parse(fs.readFileSync(bla + '/base de dados/random/ANIMES-HENTAI/hestia.json'));
    const randhestia = hestia[Math.floor(Math.random() * hestia.length)];
    data = await fetch(randhestia).then(v => v.buffer())
    await fs.writeFileSync(bla + '/assets/hestia.jpeg', data)
    res.sendFile(bla + '/assets/hestia.jpeg')
  } else {
  res.json({erro:'Erro no Servidor Interno'})
  }
})

router.get('/random/inori', async (req, res, next) => {
      var apikey = req.query.apikey;
if(!apikey)return res.json({status:false,message:'- CadÃª o parÃ¢metro apikey?'})
if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
RegisKey(apikey, req);
	if(key.map(i => i.apikey)?.includes(apikey)){    

    const inori = JSON.parse(fs.readFileSync(bla + '/base de dados/random/ANIMES-HENTAI/inori.json'));
    const randinori = inori[Math.floor(Math.random() * inori.length)];
    data = await fetch(randinori).then(v => v.buffer())
    await fs.writeFileSync(bla + '/assets/inori.jpeg', data)
    res.sendFile(bla + '/assets/inori.jpeg')
  } else {
  res.json({erro:'Erro no Servidor Interno'})
  }
})

router.get('/random/ana', async (req, res, next) => {
      var apikey = req.query.apikey;
if(!apikey)return res.json({status:false,message:'- CadÃª o parÃ¢metro apikey?'})
if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
RegisKey(apikey, req);
	if(key.map(i => i.apikey)?.includes(apikey)){    

    const ana = JSON.parse(fs.readFileSync(bla + '/base de dados/random/ANIMES-HENTAI/ana.json'));
    const randana = ana[Math.floor(Math.random() * ana.length)];
    data = await fetch(randana).then(v => v.buffer())
    await fs.writeFileSync(bla + '/assets/ana.jpeg', data)
    res.sendFile(bla + '/assets/ana.jpeg')
  } else {
  res.json({erro:'Erro no Servidor Interno'})
  }
})

router.get('/random/boruto', async (req, res, next) => {
      var apikey = req.query.apikey;
if(!apikey)return res.json({status:false,message:'- CadÃª o parÃ¢metro apikey?'})
if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
RegisKey(apikey, req);
	if(key.map(i => i.apikey)?.includes(apikey)){    

    const Boruto = JSON.parse(fs.readFileSync(bla + '/base de dados/random/ANIMES-HENTAI/boruto.json'));
    const randBoruto = Boruto[Math.floor(Math.random() * Boruto.length)];
    data = await fetch(randBoruto).then(v => v.buffer())
    await fs.writeFileSync(bla + '/assets/bor.jpeg', data)
    res.sendFile(bla + '/assets/bor.jpeg')
  } else {
  res.json({erro:'Erro no Servidor Interno'})
  }
})

router.get('/random/erza', async (req, res, next) => {
      var apikey = req.query.apikey;
if(!apikey)return res.json({status:false,message:'- CadÃª o parÃ¢metro apikey?'})
if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
RegisKey(apikey, req);
	if(key.map(i => i.apikey)?.includes(apikey)){    

    const Erza = JSON.parse(fs.readFileSync(bla + '/base de dados/random/ANIMES-HENTAI/erza.json'));
    const randErza = Erza[Math.floor(Math.random() * Erza.length)];
    data = await fetch(randErza).then(v => v.buffer())
    await fs.writeFileSync(bla + '/assets/erza.jpeg', data)
    res.sendFile(bla + '/assets/erza.jpeg')
  } else {
  res.json({erro:'Erro no Servidor Interno'})
  }
})

router.get('/random/kakashi', async (req, res, next) => {
      var apikey = req.query.apikey;
if(!apikey)return res.json({status:false,message:'- CadÃª o parÃ¢metro apikey?'})
if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
RegisKey(apikey, req);
	if(key.map(i => i.apikey)?.includes(apikey)){    

    const Kakasih = JSON.parse(fs.readFileSync(bla + '/base de dados/random/ANIMES-HENTAI/kakasih.json'));
    const randKakasih = Kakasih[Math.floor(Math.random() * Kakasih.length)];
    data = await fetch(randKakasih).then(v => v.buffer())
    await fs.writeFileSync(bla + '/assets/ka.jpeg', data)
    res.sendFile(bla + '/assets/ka.jpeg')
  } else {
  res.json({erro:'Erro no Servidor Interno'})
  }
})

router.get('/random/sagiri', async (req, res, next) => {
      var apikey = req.query.apikey;
if(!apikey)return res.json({status:false,message:'- CadÃª o parÃ¢metro apikey?'})
if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
RegisKey(apikey, req);
	if(key.map(i => i.apikey)?.includes(apikey)){    

    const Sagiri = JSON.parse(fs.readFileSync(bla + '/base de dados/random/ANIMES-HENTAI/sagiri.json'));
    const randSagiri = Sagiri[Math.floor(Math.random() * Sagiri.length)];
    data = await fetch(randSagiri).then(v => v.buffer())
    await fs.writeFileSync(bla + '/assets/sagiri.jpeg', data)
    res.sendFile(bla + '/assets/sagiri.jpeg')
  } else {
  res.json({erro:'Erro no Servidor Interno'})
  }
})

router.get('/random/minato', async (req, res, next) => {
      var apikey = req.query.apikey;
if(!apikey)return res.json({status:false,message:'- CadÃª o parÃ¢metro apikey?'})
if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
RegisKey(apikey, req);
	if(key.map(i => i.apikey)?.includes(apikey)){    

    const Minato = JSON.parse(fs.readFileSync(bla + '/base de dados/random/ANIMES-HENTAI/minato.json'));
    const randMinato = Minato[Math.floor(Math.random() * Minato.length)];
    data = await fetch(randMinato).then(v => v.buffer())
    await fs.writeFileSync(bla + '/assets/minato.jpeg', data)
    res.sendFile(bla + '/assets/minato.jpeg')
  } else {
  res.json({erro:'Erro no Servidor Interno'})
  }
})

router.get('/random/naruto', async (req, res, next) => {
      var apikey = req.query.apikey;
if(!apikey)return res.json({status:false,message:'- CadÃª o parÃ¢metro apikey?'})
if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
RegisKey(apikey, req);
	if(key.map(i => i.apikey)?.includes(apikey)){    

    const Naruto = JSON.parse(fs.readFileSync(bla + '/base de dados/random/ANIMES-HENTAI/naruto.json'));
    const randNaruto = Naruto[Math.floor(Math.random() * Naruto.length)];
    data = await fetch(randNaruto).then(v => v.buffer())
    await fs.writeFileSync(bla + '/assets/naruto.jpeg', data)
    res.sendFile(bla + '/assets/naruto.jpeg')
  } else {
  res.json({erro:'Erro no Servidor Interno'})
  }
})

router.get('/random/nezuko', async (req, res, next) => {
      var apikey = req.query.apikey;
if(!apikey)return res.json({status:false,message:'- CadÃª o parÃ¢metro apikey?'})
if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
RegisKey(apikey, req);
	if(key.map(i => i.apikey)?.includes(apikey)){    

    const Nezuko = JSON.parse(fs.readFileSync(bla + '/base de dados/random/ANIMES-HENTAI/nezuko.json'));
    const randNezuko = Nezuko[Math.floor(Math.random() * Nezuko.length)];
    data = await fetch(randNezuko).then(v => v.buffer())
    await fs.writeFileSync(bla + '/assets/nezu.jpeg', data)
    res.sendFile(bla + '/assets/nezu.jpeg')
  } else {
  res.json({erro:'Erro no Servidor Interno'})
  }
})

router.get('/random/onepiece', async (req, res, next) => {
      var apikey = req.query.apikey;
if(!apikey)return res.json({status:false,message:'- CadÃª o parÃ¢metro apikey?'})
if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
RegisKey(apikey, req);
	if(key.map(i => i.apikey)?.includes(apikey)){    

    const Pic = JSON.parse(fs.readFileSync(bla + '/base de dados/random/ANIMES-HENTAI/onepiece.json'));
    const randPic = Pic[Math.floor(Math.random() * Pic.length)];
    data = await fetch(randPic).then(v => v.buffer())
    await fs.writeFileSync(bla + '/assets/pic.jpeg', data)
    res.sendFile(bla + '/assets/pic.jpeg')
  } else {
  res.json({erro:'Erro no Servidor Interno'})
  }
})

router.get('/random/rize', async (req, res, next) => {
      var apikey = req.query.apikey;
if(!apikey)return res.json({status:false,message:'- CadÃª o parÃ¢metro apikey?'})
if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
RegisKey(apikey, req);
	if(key.map(i => i.apikey)?.includes(apikey)){    

    const Rize = JSON.parse(fs.readFileSync(bla + '/base de dados/random/ANIMES-HENTAI/rize.json'));
    const randRize = Rize[Math.floor(Math.random() * Rize.length)];
    data = await fetch(randRize).then(v => v.buffer())
    await fs.writeFileSync(bla + '/assets/rize.jpeg', data)
    res.sendFile(bla + '/assets/rize.jpeg')
  } else {
  res.json({erro:'Erro no Servidor Interno'})
  }
})

router.get('/random/sakura', async (req, res, next) => {
      var apikey = req.query.apikey;
if(!apikey)return res.json({status:false,message:'- CadÃª o parÃ¢metro apikey?'})
if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
RegisKey(apikey, req);
	if(key.map(i => i.apikey)?.includes(apikey)){    

    const Sakura = JSON.parse(fs.readFileSync(bla + '/base de dados/random/ANIMES-HENTAI/sakura.json'));
    const randSakura = Sakura[Math.floor(Math.random() * Sakura.length)];
    data = await fetch(randSakura).then(v => v.buffer())
    await fs.writeFileSync(bla + '/assets/sakura.jpeg', data)
    res.sendFile(bla + '/assets/sakura.jpeg')
  } else {
  res.json({erro:'Erro no Servidor Interno'})
  }
})

router.get('/random/sasuke', async (req, res, next) => {
      var apikey = req.query.apikey;
if(!apikey)return res.json({status:false,message:'- CadÃª o parÃ¢metro apikey?'})
if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
RegisKey(apikey, req);
	if(key.map(i => i.apikey)?.includes(apikey)){    

    const Sasuke = JSON.parse(fs.readFileSync(bla + '/base de dados/random/ANIMES-HENTAI/sasuke.json'));
    const randSasuke = Sasuke[Math.floor(Math.random() * Sasuke.length)];
    data = await fetch(randSasuke).then(v => v.buffer())
    await fs.writeFileSync(bla + '/assets/sasuke.jpeg', data)
    res.sendFile(bla + '/assets/sasuke.jpeg')
  } else {
  res.json({erro:'Erro no Servidor Interno'})
  }
})

router.get('/random/tsunade', async (req, res, next) => {
      var apikey = req.query.apikey;
if(!apikey)return res.json({status:false,message:'- CadÃª o parÃ¢metro apikey?'})
if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
RegisKey(apikey, req);
	if(key.map(i => i.apikey)?.includes(apikey)){    

    const Su = JSON.parse(fs.readFileSync(bla + '/base de dados/random/ANIMES-HENTAI/tsunade.json'));
    const randSu = Su[Math.floor(Math.random() * Su.length)];
    data = await fetch(randSu).then(v => v.buffer())
    await fs.writeFileSync(bla + '/assets/su.jpeg', data)
    res.sendFile(bla + '/assets/su.jpeg')
  } else {
  res.json({erro:'Erro no Servidor Interno'})
  }
})

router.get('/random/montor', async (req, res, next) => {
      var apikey = req.query.apikey;
if(!apikey)return res.json({status:false,message:'- CadÃª o parÃ¢metro apikey?'})
if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
RegisKey(apikey, req);
	if(key.map(i => i.apikey)?.includes(apikey)){    

    const Mon = JSON.parse(fs.readFileSync(bla + '/base de dados/random/ANIMES-HENTAI/montor.json'));
    const randMon = Mon[Math.floor(Math.random() * Mon.length)];
    data = await fetch(randMon).then(v => v.buffer());
    await fs.writeFileSync(bla + '/assets/montor.jpeg', data)
    res.sendFile(bla + '/assets/montor.jpeg');
  } else {
  res.json({erro:'Erro no Servidor Interno'})
  }
})

router.get('/random/mobil', async (req, res, next) => {
      var apikey = req.query.apikey;
if(!apikey)return res.json({status:false,message:'- CadÃª o parÃ¢metro apikey?'})
if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
RegisKey(apikey, req);
	if(key.map(i => i.apikey)?.includes(apikey)){    

    const Mob = JSON.parse(fs.readFileSync(bla + '/base de dados/random/ANIMES-HENTAI/mobil.json'));
    const randMob = Mob[Math.floor(Math.random() * Mob.length)];
    data = await fetch(randMob).then(v => v.buffer());
    await fs.writeFileSync(bla + '/assets/mobil.jpeg', data)
    res.sendFile(bla + '/assets/mobil.jpeg');
  } else {
  res.json({erro:'Erro no Servidor Interno'})
  }
})


router.get('/random/anime', async (req, res, next) => {
      var apikey = req.query.apikey;
if(!apikey)return res.json({status:false,message:'- CadÃª o parÃ¢metro apikey?'})
if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
RegisKey(apikey, req);
	if(key.map(i => i.apikey)?.includes(apikey)){    

    const Wai23 = JSON.parse(fs.readFileSync(bla + '/base de dados/random/ANIMES-HENTAI/wallhp2.json'));
    const randWai23 = Wai23[Math.floor(Math.random() * Wai23.length)];
    data = await fetch(randWai23).then(v => v.buffer());
    await fs.writeFileSync(bla + '/assets/wallhp2.jpeg', data)
    res.sendFile(bla + '/assets/wallhp2.jpeg');
  } else {
  res.json({erro:'Erro no Servidor Interno'})
  }
})


router.get('/random/wallhp', async (req, res, next) => {
      var apikey = req.query.apikey;
if(!apikey)return res.json({status:false,message:'- CadÃª o parÃ¢metro apikey?'})
if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
RegisKey(apikey, req);
	if(key.map(i => i.apikey)?.includes(apikey)){    

    const Wai22 = JSON.parse(fs.readFileSync(bla + '/base de dados/random/ANIMES-HENTAI/wallhp.json'));
    const randWai22 = Wai22[Math.floor(Math.random() * Wai22.length)];
    data = await fetch(randWai22).then(v => v.buffer());
    await fs.writeFileSync(bla + '/assets/wallhp.jpeg', data)
    res.sendFile(bla + '/assets/wallhp.jpeg');
  } else {
  res.json({erro:'Erro no Servidor Interno'})
  }
})

router.get('/random/waifu2', async (req, res, next) => {
      var apikey = req.query.apikey;
if(!apikey)return res.json({status:false,message:'- CadÃª o parÃ¢metro apikey?'})
if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
RegisKey(apikey, req);
	if(key.map(i => i.apikey)?.includes(apikey)){    

    const Wai2 = JSON.parse(fs.readFileSync(bla + '/base de dados/random/ANIMES-HENTAI/waifu2.json'));
    const randWai2 = Wai2[Math.floor(Math.random() * Wai2.length)];
    data = await fetch(randWai2).then(v => v.buffer());
    await fs.writeFileSync(bla + '/assets/wibu2.jpeg', data)
    res.sendFile(bla + '/assets/wibu2.jpeg');
  } else {
  res.json({erro:'Erro no Servidor Interno'})
  }
})

router.get('/random/waifu', async (req, res, next) => {
      var apikey = req.query.apikey;
if(!apikey)return res.json({status:false,message:'- CadÃª o parÃ¢metro apikey?'})
if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
RegisKey(apikey, req);
	if(key.map(i => i.apikey)?.includes(apikey)){    

    const Wai = JSON.parse(fs.readFileSync(bla + '/base de dados/random/ANIMES-HENTAI/waifu.json'));
    const randWai = Wai[Math.floor(Math.random() * Wai.length)];
    data = await fetch(randWai).then(v => v.buffer());
    await fs.writeFileSync(bla + '/assets/wibu.jpeg', data)
    res.sendFile(bla + '/assets/wibu.jpeg');
  } else {
  res.json({erro:'Erro no Servidor Interno'})
  }
})


router.get('/random/hekel', async (req, res, next) => {
      var apikey = req.query.apikey;
if(!apikey)return res.json({status:false,message:'- CadÃª o parÃ¢metro apikey?'})
if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
RegisKey(apikey, req);
	if(key.map(i => i.apikey)?.includes(apikey)){    

    Hekel = JSON.parse(fs.readFileSync(bla + '/base de dados/random/ANIMES-HENTAI/hekel.json'));
    const randHekel = Hekel[Math.floor(Math.random() * Hekel.length)]
    data = await fetch(randHekel).then(v => v.buffer())
    await fs.writeFileSync(bla + '/assets/hek.jpeg', data)
    res.sendFile(bla + '/assets/hek.jpeg')
  } else {
  res.json({erro:'Erro no Servidor Interno'})
  }
})

router.get('/random/kucing', async (req, res, next) => {
      var apikey = req.query.apikey;
if(!apikey)return res.json({status:false,message:'- CadÃª o parÃ¢metro apikey?'})
if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
RegisKey(apikey, req);
	if(key.map(i => i.apikey)?.includes(apikey)){    

    Kucing = JSON.parse(fs.readFileSync(bla + '/base de dados/random/ANIMES-HENTAI/kucing.json'));
    const randKucing = Kucing[Math.floor(Math.random() * Kucing.length)]
    data = await fetch(randKucing).then(v => v.buffer())
    await fs.writeFileSync(bla + '/assets/kucing.jpeg', data)
    res.sendFile(bla + '/assets/kucing.jpeg')
  } else {
  res.json({erro:'Erro no Servidor Interno'})
  }
})

router.get('/wallpaper/pubg', async (req, res, next) => {
      var apikey = req.query.apikey;
if(!apikey)return res.json({status:false,message:'- CadÃª o parÃ¢metro apikey?'})
if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
RegisKey(apikey, req);
	if(key.map(i => i.apikey)?.includes(apikey)){    

    Pubg = JSON.parse(fs.readFileSync(bla + '/base de dados/random/ANIMES-HENTAI/pubg.json'));
    const randPubg = Pubg[Math.floor(Math.random() * Pubg.length)]
    data = await fetch(randPubg).then(v => v.buffer())
    await fs.writeFileSync(bla + '/assets/pubg.jpeg', data)
    res.sendFile(bla + '/assets/pubg.jpeg')
  } else {
  res.json({erro:'Erro no Servidor Interno'})
  }
})

router.get('/wallpaper/ppcouple', async (req, res, next) => {
      var apikey = req.query.apikey;
if(!apikey)return res.json({status:false,message:'- CadÃª o parÃ¢metro apikey?'})
if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
RegisKey(apikey, req);
	if(key.map(i => i.apikey)?.includes(apikey)){    

    Pp = JSON.parse(fs.readFileSync(bla + '/base de dados/random/ANIMES-HENTAI/profil.json'));
    const randPp = Pp[Math.floor(Math.random() * Pp.length)]
    data = await fetch(randPp).then(v => v.buffer())
    await fs.writeFileSync(bla + '/assets/pp.jpeg', data)
    res.sendFile(bla + '/assets/pp.jpeg')
  } else {
  res.json({erro:'Erro no Servidor Interno'})
  }
})

router.get('/wallpaper/anjing', async (req, res, next) => {
      var apikey = req.query.apikey;
if(!apikey)return res.json({status:false,message:'- CadÃª o parÃ¢metro apikey?'})
if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
RegisKey(apikey, req);
	if(key.map(i => i.apikey)?.includes(apikey)){    

    Anjing = JSON.parse(fs.readFileSync(bla + '/base de dados/random/ANIMES-HENTAI/anjing.json'));
    const randAnjing = Anjing[Math.floor(Math.random() * Anjing.length)]
    data = await fetch(randAnjing).then(v => v.buffer())
    await fs.writeFileSync(bla + '/assets/ajg.jpeg', data)
    res.sendFile(bla + '/assets/ajg.jpeg')
  } else {
  res.json({erro:'Erro no Servidor Interno'})
  }
})

router.get('/random/doraemon', async (req, res, next) => {
      var apikey = req.query.apikey;
if(!apikey)return res.json({status:false,message:'- CadÃª o parÃ¢metro apikey?'})
if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
RegisKey(apikey, req);
	if(key.map(i => i.apikey)?.includes(apikey)){    

    Dora = JSON.parse(fs.readFileSync(bla + '/base de dados/random/ANIMES-HENTAI/doraemon.json'));
    const randDora = Dora[Math.floor(Math.random() * Dora.length)]
    data = await fetch(randDora).then(v => v.buffer())
    await fs.writeFileSync(bla + '/assets/dora.jpeg', data)
    res.sendFile(bla + '/assets/dora.jpeg')
  } else {
  res.json({erro:'Erro no Servidor Interno'})
  }
})


router.get('/random/elaina', async (req, res, next) => {
      var apikey = req.query.apikey;
if(!apikey)return res.json({status:false,message:'- CadÃª o parÃ¢metro apikey?'})
if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
RegisKey(apikey, req);
	if(key.map(i => i.apikey)?.includes(apikey)){    
    const Elaina = JSON.parse(fs.readFileSync(bla + '/base de dados/random/ANIMES-HENTAI/elaina.json'))
    const randElaina = Elaina[Math.floor(Math.random() * Elaina.length)]
    //tansole.log(randLoli)
    data = await fetch(randElaina).then(v => v.buffer())
    await fs.writeFileSync(bla + '/assets/elaina.jpeg', data)
    res.sendFile(bla + '/assets/elaina.jpeg')
  } else {
  res.json({erro:'Erro no Servidor Interno'})
  }
})


router.get('/random/loli', async (req, res, next) => {
      var apikey = req.query.apikey;
if(!apikey)return res.json({status:false,message:'- CadÃª o parÃ¢metro apikey?'})
if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
RegisKey(apikey, req);
	if(key.map(i => i.apikey)?.includes(apikey)){    
    const Loli = JSON.parse(fs.readFileSync(bla + '/base de dados/random/ANIMES-HENTAI/loli.json'))
    const randLoli = Loli[Math.floor(Math.random() * Loli.length)]
    //tansole.log(randLoli)
    data = await fetch(randLoli).then(v => v.buffer())
    await fs.writeFileSync(bla + '/assets/loli.jpeg', data)
    res.sendFile(bla + '/assets/loli.jpeg')
  } else {
  res.json({erro:'Erro no Servidor Interno'})
  }
})


router.get('/random/yuri', async (req, res, next) => {
      var apikey = req.query.apikey;
if(!apikey)return res.json({status:false,message:'- CadÃª o parÃ¢metro apikey?'})
if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
RegisKey(apikey, req);
	if(key.map(i => i.apikey)?.includes(apikey)){    
    const Yuri = JSON.parse(fs.readFileSync(bla + '/base de dados/random/ANIMES-HENTAI/yuri.json'))
    const randYuri = Yuri[Math.floor(Math.random() * Yuri.length)]
    //tansole.log(randTech)
    data = await fetch(randYuri).then(v => v.buffer())
    await fs.writeFileSync(bla + '/assets/Yuri.jpeg', data)
    res.sendFile(bla + '/assets/Yuri.jpeg')
  } else {
  res.json({erro:'Erro no Servidor Interno'})
  }
})


router.get('/random/cecan', async (req, res, next) => {
      var apikey = req.query.apikey;
if(!apikey)return res.json({status:false,message:'- CadÃª o parÃ¢metro apikey?'})
if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
RegisKey(apikey, req);
	if(key.map(i => i.apikey)?.includes(apikey)){    

    const cecan = JSON.parse(fs.readFileSync(bla + '/base de dados/random/ANIMES-HENTAI/cecan.json'));
    const randCecan = cecan[Math.floor(Math.random() * cecan.length)];
    data = await fetch(randCecan).then(v => v.buffer());
    await fs.writeFileSync(bla + '/assets/cecan.jpeg', data)
    res.sendFile(bla + '/assets/cecan.jpeg');
  } else {
  res.json({erro:'Erro no Servidor Interno'})
  }
})


router.get('/wallpaper/aesthetic', async (req, res, next) => {
      var apikey = req.query.apikey;
if(!apikey)return res.json({status:false,message:'- CadÃª o parÃ¢metro apikey?'})
if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
RegisKey(apikey, req);
	if(key.map(i => i.apikey)?.includes(apikey)){    

    const Aesthetic = JSON.parse(fs.readFileSync(bla + '/base de dados/random/ANIMES-HENTAI/aesthetic.json'));
    const randAesthetic = Aesthetic[Math.floor(Math.random() * Aesthetic.length)];
    data = await fetch(randAesthetic).then(v => v.buffer());
    await fs.writeFileSync(bla + '/assets/aesthetic.jpeg', data)
    res.sendFile(bla + '/assets/aesthetic.jpeg');
  } else {
  res.json({erro:'Erro no Servidor Interno'})
  }
})



router.get('/random/sagiri', async (req, res, next) => {
      var apikey = req.query.apikey;
if(!apikey)return res.json({status:false,message:'- CadÃª o parÃ¢metro apikey?'})
if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
RegisKey(apikey, req);
	if(key.map(i => i.apikey)?.includes(apikey)){    

    const Sagiri = JSON.parse(fs.readFileSync(bla + '/base de dados/random/ANIMES-HENTAI/sagiri.json'));
    const randSagiri = Sagiri[Math.floor(Math.random() * Sagiri.length)];
    data = await fetch(randSagiri).then(v => v.buffer())
    await fs.writeFileSync(bla + '/assets/sagiri.jpeg', data)
    res.sendFile(bla + '/assets/sagiri.jpeg')
  } else {
  res.json({erro:'Erro no Servidor Interno'})
  }
})

router.get('/random/shota', async (req, res, next) => {
      var apikey = req.query.apikey;
if(!apikey)return res.json({status:false,message:'- CadÃª o parÃ¢metro apikey?'})
if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
RegisKey(apikey, req);
	if(key.map(i => i.apikey)?.includes(apikey)){    

    const Shota = JSON.parse(fs.readFileSync(bla + '/base de dados/random/ANIMES-HENTAI/shota.json'));
    const randShota = Shota[Math.floor(Math.random() * Shota.length)];
    data = await fetch(randShota).then(v => v.buffer());
    await fs.writeFileSync(bla + '/assets/shota.jpeg', data)
    res.sendFile(bla + '/assets/shota.jpeg');
  } else {
  res.json({erro:'Erro no Servidor Interno'})
  }
})

router.get('/random/nsfwloli', async (req, res, next) => {
      var apikey = req.query.apikey;
if(!apikey)return res.json({status:false,message:'- CadÃª o parÃ¢metro apikey?'})
if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
RegisKey(apikey, req);
	if(key.map(i => i.apikey)?.includes(apikey)){    

    const lol = JSON.parse(fs.readFileSync(bla + '/base de dados/random/ANIMES-HENTAI/nsfwloli.json'));
    const randlol = lol[Math.floor(Math.random() * lol.length)];
    data = await fetch(randlol).then(v => v.buffer());
    await fs.writeFileSync(bla + '/assets/lol.jpeg', data)
    res.sendFile(bla + '/assets/lol.jpeg');
  } else {
  res.json({erro:'Erro no Servidor Interno'})
  }
})

router.get('/random/hinata', async (req, res, next) => {
      var apikey = req.query.apikey;
if(!apikey)return res.json({status:false,message:'- CadÃª o parÃ¢metro apikey?'})
if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
RegisKey(apikey, req);
	if(key.map(i => i.apikey)?.includes(apikey)){    
    const Hinata = JSON.parse(fs.readFileSync(bla + '/base de dados/random/ANIMES-HENTAI/hinata.json'));
    const randHin = Hinata[Math.floor(Math.random() * Hinata.length)];
    data = await fetch(randHin).then(v => v.buffer());
    await fs.writeFileSync(bla + '/assets/Hinata.jpeg', data)
    res.sendFile(bla + '/assets/Hinata.jpeg');
  } else {
  res.json({erro:'Erro no Servidor Interno'})
  }
})

 app.get('/api/soundcloud', async(req, res, next) => {
 apikey = req.query.apikey;
 url = req.query.url
if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
if (!url) return res.json({ status : false,  message: "Coloque o parametro: url"})
RegisKey(apikey, req);
soundl(url).then((resultado) => {
 res.json({
 status: true,
 cÃ³digo: 200,
 resultado: resultado
 })}).catch(e => {
res.json({
 message: `Erro no Servidor Interno`
 })})})

 app.get('/api/manga', async(req, res, next) => {
 apikey = req.query.apikey;
q = req.query.q
if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
if (!q) return res.json({ status : false,  message: "Coloque o parametro: q"})
RegisKey(apikey, req);
manga(q).then((resultado) => {
 res.json({
 status: true,
 cÃ³digo: 200,
 resultado: resultado
 })}).catch(e => {
res.json({
 message: `Erro no Servidor Interno`
 })})})

 app.get('/api/hentaistube', async(req, res, next) => {
 apikey = req.query.apikey;
q = req.query.q
if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
if (!q) return res.json({ status : false,  message: "Coloque o parametro: q"})
RegisKey(apikey, req);
hentaistube(q).then((resultado) => {
 res.json({
 status: true,
 cÃ³digo: 200,
 resultado: resultado
 })}).catch(e => {
res.json({
 message: `Erro no Servidor Interno`
 })})})

app.get('/api/icms', async(req, res, next) => {
var { apikey, valor, ddd } = req.query
if(!apikey) return res.json({status:false,message:'cade o parametro apikey'})
if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
if (!valor) return res.json({ status : false,  message: "Coloque o parametro: valor"})
if (!ddd) return res.json({ status : false,  message: "Coloque o parametro: ddd"})
RegisKey(apikey, req);
icms(valor, ddd).then((data) => {
res.json({status: 200, credits: "Crap Ethern-Bot </Dev>", resultado: data})
}).catch(e => {
res.json({
message: `Erro no Servidor Interno`
})
})
})

app.get('/api/ddd', async(req, res, next) => {
var { ddd, apikey } = req.query
if(!ddd) return res.json({status:false,message:'cade o parametro DDD'})
if(!apikey) return res.json({status:false,message:'cade o parametro apikey'})
if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
RegisKey(apikey, req);
try {
ddds = await axios.get(`https://brasilapi.com.br/api/ddd/v1/${ddd}`)
caixa = []
for(i = 0; i < ddds.data.cities.length; i++) {
caixa.push(ddds.data.cities[i])
}
return res.json({criador: "@m4thxyz_", cidade: ddds.data.state, resultado: caixa})
} catch { res.json({erro: "Erro no servidor interno"}) }
})

app.get('/api/brasileirao', async(req, res, next) => {
var { apikey } = req.query
if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
RegisKey(apikey, req);
BrasileirÃ£oFutebol().then((data) => {
res.json({status: 200, resultado: data})
}).catch(e => {
res.json({
message: `Erro no Servidor Interno`
})
})
})

/*app.get('/api/brasileirao/campeonato', async(req, res, next) => {
var { ano, serie, apikey } = req.query
if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
RegisKey(apikey, req);
cb.jogos(Number(ano), serie).then(ABC => {
return res.json({resultado: ABC})
}).catch(e => {
return res.json({resultado: e})
})
})

app.get('/api/brasileirao/tabela', async(req, res, next) => {
var { serie, apikey } = req.query
if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
RegisKey(apikey, req);
cb.tabela(serie).then(ABC => {
return res.json({resultado: ABC})
}).catch(e => {
return res.json({resultado: e})
})
})*/

app.get('/api/ttp',  async (req, res) => {
texto = req.query.texto
if(!texto)return res.json({
status:false,
message:'Cade o parametro texto??'
})
apikey = req.query.apikey
if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
RegisKey(apikey, req);
cor = ["f702ff","ff0202","00ff2e","efff00","00ecff","3100ff","ffb400","ff00b0","00ff95","efff00"] //CORES COLOQUE QUALQUER UMA MAS EM CODE
fonte = ["Days%20One","Domine","Exo","Fredoka%20One","Gentium%20Basic","Gloria%20Hallelujah","Great%20Vibes","Orbitron","PT%20Serif","Pacifico"]//FONTS NÃƒO MEXA
cores = cor[Math.floor(Math.random() * (cor.length))]	 				 
fontes = fonte[Math.floor(Math.random() * (fonte.length))]	 		
sitee = `https://huratera.sirv.com/PicsArt_08-01-10.00.42.png?profile=Example-Text&text.0.text=${texto}&text.0.outline.color=000000&text.0.outline.blur=0&text.0.outline.opacity=55&text.0.color=${cores}&text.0.font.family=${fontes}&text.0.background.color=ff0000`
res.type('jpg')
res.send(await getBuffer(sitee))
})

app.get('/api/fbdown',(req,res) => {
url = req.query.url
if(!url)return res.json({
status:false,
message:'Cade o parametro url??'
})
apikey = req.query.apikey
if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
RegisKey(apikey, req);
down.fbdown(url)
.then(e => {
res.json({
status:true,
resultado: e})
}).catch(e => {
res.json({erro:'Erro no Servidor Interno'})
})
})

app.get('/api/photooxy',(req,res) => {
url = req.query.url
text = req.query.text
if(!url)return res.json({
status:false,
message:'Cade o parametro url??'
})
if(!text)return res.json({
status:false,
message:'Cade o parametro text??'
})
apikey = req.query.apikey
if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
RegisKey(apikey, req);
photooxy(url, text)
.then(e => {
res.json({
status:true,
resultado: e})
}).catch(e => {
res.json({erro:'Erro no Servidor Interno'})
})
})

app.get('/api/wallpaperanime',(req,res) => {
apikey = req.query.apikey
q = 'Wallpaper anime'
if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
RegisKey(apikey, req);
gis(q, async (error, results) => {
if (error) {
console.log(error)
res.json({
status:false,
message:'NÃ£o encontrei imagem'
})
} else {
bala = await getBuffer(results[1].url)
res.type('jpg')
res.send(bala)
}
}).catch(e => {
res.json({erro:'Erro no Servidor Interno'})
})
})

app.get("/api/google-img", async(req, res) => {
try {
apikey = req.query.apikey
nome = req.query.nome
if(!nome) return res.json({message: "Faltando o parametro nome"})
if(!apikey)return res.json({message:'cade o parametro apikey'})
if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
RegisKey(apikey, req);
await gis(nome, logResults);
function logResults(error, results) {
if (error) {
console.log(error);
return res.json({message: "Erro.."})
} else {
return res.send(results)
}
}
} catch (e) {
return res.json({message: "Erro.."})
}
})

app.get('/api/ssweb',async (req,res,next) => {
url = req.query.url
if(!url)return res.json({
status:false,
motivo:'nao_tem_url'
})
apikey = req.query.apikey
if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
RegisKey(apikey, req);
fetch('https://mnazria.herokuapp.com/api/screenshotweb?url='+url, async(error, results) => {
if(error){
console.log(error)
res.json({
status:false,
message:'NÃ£o encontrei o site'
})
} else { 
resultado = results
bala = await getBuffer(resultado.gambar)
res.type('jpg')
res.send(bala)
}
}).catch(e => {
res.json({erro:'Erro no Servidor Interno'})
})
})

app.get('/api/avatar',(req,res,next) => {
var { apikey } = req.query
if(!key.map(i => i.apikey)?.includes(apikey)) return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
RegisKey(apikey, req);
fetch(encodeURI(`https://nekos.life/api/v2/img/avatar`))
.then(response => response.json())
.then(async (data) => {
resultado =  data
bala = await getBuffer(resultado.url)
res.type('jpg')
res.send(bala)
})
.catch(e => {
res.json({erro:'erro'})
})
})

app.get('/api/tempmail/criar-email', async(req, res, next) => {
var apikey = req.query.apikey
if(!key.map(i => i.apikey)?.includes(apikey)) return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
RegisKey(apikey, req);
try {
var resS = await axios.get('https://www.1secmail.com/api/v1/?action=genRandomMailbox')
var data = await resS.data;
res.json({
status: true,
criador: `@m4thxyz_`,
resultado: data[0]
})
} catch (err) {
res.json({resultado: `Erro`})
};
})
 
app.get('/api/tempmail/ler-inbox', async(req, res, next) => {
var { domain, login, apikey } = req.query
if(!domain) return res.json({status:false,resultado: 'CadÃª o parÃ¢metro domain?'})
if(!login) return res.json({status:false,resultado: 'CadÃª o parÃ¢metro login?'})
if(!key.map(i => i.apikey)?.includes(apikey)) return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
RegisKey(apikey, req);
try {
var ress = await axios.get(`https://www.1secmail.com/api/v1/?action=getMessages&login=${login}&domain=${domain}`);
var data = ress.data;
res.json({
status: true,
criador: `@m4thxyz_`, 
resultado: data
})
} catch (err) {
res.json({resultado: `Erro`})
};
}) 

app.get('/api/legenda',async (req,res,next) => {
url = req.query.url
texto1 = req.query.texto1
texto2 = req.query.texto2
if(!url)return res.json({
status:false,
motivo:'nao_tem_url'
})
if(!texto1)return res.json({
status:false,
motivo:'nao_tem_texto_1'
})
if(!texto2)return res.json({
status:false,
motivo:'nao_tem_texto_2'
})
apikey = req.query.apikey
if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
RegisKey(apikey, req);
bala = await getBuffer(`https://api.memegen.link/images/custom/${texto1}/${texto2}.png?background=${url}`)
res.type('jpg')
res.send(bala)
})

app.get('/api/github',(req,res,next) => {
pessoa = req.query.usuario
if(!pessoa)return res.json({
status:false,
motivo:'cade_o_usuario'
})
apikey = req.query.apikey
if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
RegisKey(apikey, req);
fetch(encodeURI(`https://api.github.com/users/`+pessoa))
.then(response => response.json())
.then(date => {
gitData =  date;
res.json({
criador:"matheuzinho ãƒ„",
status:true,
resultado:{
username: gitData.login,
id: gitData.id,
Node_ID: gitData.node_id,
url: gitData.html_url,
local: (gitData.location == null) ? 'nÃ£o_tem' : gitData.location,
bio: (gitData.bio == null) ? 'nÃ£o_tem' : gitData.bio,
twitter:  (gitData.twitter_username == null) ? 'nÃ£o_tem' : gitData.twitter_username,
seguidores: gitData.followers,
seguindo: gitData.following,
criado: gitData.created_at,
atualizado: gitData.updated_at,
procura_trabalho: (gitData.hireable == null) ? 'NÃ£o' : gitData.hireable,
Site: (gitData.blog == "") ? 'NÃ£o' : gitData.blog,
repositorios: gitData.public_repos,
admin_de_Site: (gitData.site_admin == false) ? 'NÃ£o' : gitData.site_admin,
tipo: gitData.type,
empresa: (gitData.company == null) ? 'NÃ£o' : gitData.company,
email: (gitData.email == null) ? 'NÃ£o' : gitData.email
} 
})
}).catch(e => {
res.json({erro:'Erro no Servidor Interno'})
})
})

app.get('/api/wiki',(req,res) => {
texto = req.query.texto
if(!texto)return res.json({
status:false,
message:'Cade o parametro texto??'
})
apikey = req.query.apikey
if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
RegisKey(apikey, req);
wiki.search(`${texto}`, 'pt')
.then(async (wikip) => {
const wikis = await axiosapp.get(`https://pt.wikipedia.org/w/api.php?format=json&action=query&prop=extracts&exintro&explaintext&redirects=1&pageids=${wikip[0].pageid}`)
const getData = Object.keys(wikis.data.query.pages)

res.json({
status:true,
resultado:wikis.data.query.pages[getData].extract
    })
}).catch(e => {
res.json({erro:'Erro no Servidor Interno'})
})
})

app.get('/api/dl/twitter2',(req,res) => {
url = req.query.url
if(!url)return res.json({status:false, message:'Cade o parametro url??'})
apikey = req.query.apikey
if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
RegisKey(apikey, req);
fetchTwitterMedia(url).then(data => {
res.json({status:true, resultado: data})
}).catch(e => {
res.json({erro:'Erro no Servidor Interno'})
})
})

app.get('/api/ytsrc',(req,res) => {
q = req.query.q
if(!q)return res.json({
status:false,
message:'Cade o parametro q??'
})
apikey = req.query.apikey
if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
RegisKey(apikey, req);
ytSearch(q)
.then(e => {
res.json({
status:true,
resultado:e
})
}).catch(e => {
res.json({erro:'Erro no Servidor Interno'})
})
})

app.get('/api/ytsrc/videos',(req,res) => {
q = req.query.q
if(!q)return res.json({
status:false,
message:'Cade o parametro q??'
})
apikey = req.query.apikey
if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
RegisKey(apikey, req);
ytVideosSearch(q)
.then(e => {
res.json({
status:true,
resultado:e
})
}).catch(e => {
res.json({erro:'Erro no Servidor Interno'})
})
})

app.get('/api/dl/ytplay', async(req, res, next) => {
apikey = req.query.apikey;
text = req.query.query
 if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
if (!text) return res.json({ status : false,  message: "Coloque o parametro: query"})
var searchYoutube = await yts(text)
var puxarResult = searchYoutube.videos[0]
var mp3 = await Mp3Download(puxarResult.url)
var mp4 = await Mp4Download(puxarResult.url)
if (!mp4 || !mp3) return res.json({erro: "EstÃ¡ faltando o url para realizar o download."})
RegisKey(apikey, req);
res.json({
     status: 200, 
     resultado: {
         titulo: mp4.title, 
         descriÃ§Ã£o: mp4.desc, 
         thumb: mp4.thumb, 
         visualizaÃ§Ãµes: mp4.views, 
         canal: puxarResult.author,
         publicado_desde: puxarResult.ago, 
         tempo: puxarResult.timestamp, 
         publicado: mp4.uploadDate         
            }, 
         mp3: {
            dl_link: mp3.result, 
            size: mp3.size
             }, 
         mp4: {
           dl_link: mp4.result, 
           size: mp4.size, 
           quality: mp4.quality
        }
}).catch(e => {
res.json({
message: `Erro no Servidor Interno`
})
})
})

app.get('/api/dl/ytdl', async(req, res, next) => {
apikey = req.query.apikey;
text = req.query.url
 if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
if (!text) return res.json({ status : false,  message: "Coloque o parametro: url"})
var mp3 = await Mp3Download(text)
var mp4 = await Mp4Download(text)
if (!mp4 || !mp3) return res.json({erro: "EstÃ¡ faltando o url para realizar o download."})
RegisKey(apikey, req);
res.json({
     status: 200, 
     resultado: {
         titulo: mp4.title, 
         descriÃ§Ã£o: mp4.desc, 
         thumb: mp4.thumb, 
         visualizaÃ§Ãµes: mp4.views, 
         publicado: mp4.uploadDate         
            }, 
         mp3: {
            dl_link: mp3.result, 
            size: mp3.size
             }, 
         mp4: {
           dl_link: mp4.result, 
           size: mp4.size, 
           quality: mp4.quality
        }
}).catch(e => {
res.json({
message: `Erro no Servidor Interno`
})
})
})

app.get('/api/ia/midjourney', async (req, res, next) => {
var apikey = req.query.apikey;
if(!apikey)return res.json({status:false,message:'- CadÃª o parÃ¢metro apikey?'})
var query = req.query.query;
if(!query)return res.json({status:false,message:'- CadÃª o parÃ¢metro query?'})
if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
RegisKey(apikey, req);
try {
require('fs').writeFileSync(bla + '/assets/gostosinha.jpg', `https://aemt.me/ai/text2img?text=${query}`, 'base64')
res.sendFile(bla + '/assets/gostosinha.jpg')
} catch(e) {
console.log(e)
res.json({erro:'Erro no Servidor Interno'})
}
})

app.get('/api/ia/toanime', async(req, res, next) => {
var { apikey, link } = req.query;
if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
if (!link) return res.json({ status : false,  message: "faltando o parametro: link"})
RegisKey(apikey, req);
try {
ABC = await fetchJson(`https://delirius-api-oficial.vercel.app/api/toanime?url=${link}`)
res.json({status: 200, resultado: {image_data: ABC.data.convert}});
} catch {
res.json({status: 404, message: `Erro no Servidor Interno.`})
}
})

app.get('/api/ia/tozombie', async(req, res, next) => {
var { apikey, link } = req.query;
if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
if (!link) return res.json({ status : false,  message: "faltando o parametro: link"})
RegisKey(apikey, req);
scrapper.toZombie(link).then(response => {
res.json({status: 200, resultado: response});
}).catch(e => {
res.json({status: 404, message: `Erro no Servidor Interno.`})
})
})

app.get('/api/ia/tohd', async(req, res, next) => {
var { apikey, link } = req.query;
if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
if (!link) return res.json({ status : false,  message: "faltando o parametro: link"})
RegisKey(apikey, req);
scrapper.EditRemini(link).then(response => {
res.json({status: 200, resultado: response});
}).catch(e => {
res.json({status: 404, message: `Erro no Servidor Interno.`})
})
})

app.get('/api/ia/removebg', async(req, res, next) => {
var { apikey, link } = req.query;
if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
if (!link) return res.json({ status : false,  message: "faltando o parametro: link"})
RegisKey(apikey, req);
scrapper.RemoveBG(link).then(response => {
res.json({status: 200, resultado: response});
}).catch(e => {
res.json({status: 404, message: `Erro no Servidor Interno.`})
})
})

router.get('/api/linkshort/tinyurl', async (req, res, next) => {
var apikey = req.query.apikey;
if(!apikey)return res.json({status:false,message:'- CadÃª o parÃ¢metro apikey?'})
var link = req.query.link;
if(!link)return res.json({status:false,message:'- CadÃª o parÃ¢metro link?'})
if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
var islink = isUrl(link)
if (!islink) return res.json({ status : false, message : "[!] insira uma url vÃ¡lido"})  
TinyURL.shorten(link, function(link, err) {
if (!err) return res.json({erro: "Erro no Servidor Interno"})
RegisKey(apikey, req);
res.json({status: true, result: link})
});	
})
	
router.get('/api/linkshort/cuttly', async (req, res, next) => {
var apikey = req.query.apikey;
if(!apikey)return res.json({status:false,message:'- CadÃª o parÃ¢metro apikey?'})
var link = req.query.link;
if(!link)return res.json({status:false,message:'- CadÃª o parÃ¢metro link?'})
if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
var islink = isUrl(link)
if (!islink) return res.json({ status : false, message : "[!] insira uma url vÃ¡lido"})  
let randomapicuttly = apicuttly[Math.floor(Math.random() * apicuttly.length)]
var hasil = await fetchJson(`https://cutt.ly/api/api.php?key=${randomapicuttly}&short=${link}`)
if (!hasil.url.shortLink) return  res.json({erro: "Erro no Servidor Interno"})
RegisKey(apikey, req);
res.json({status: true, Criador: `@m4thxyz_`,result: hasil.url.shortLink})
});


router.get('/api/linkshort/bitly', async (req, res, next) => {
var apikey = req.query.apikey;
if(!apikey)return res.json({status:false,message:'- CadÃª o parÃ¢metro apikey?'})
var link = req.query.link;
if(!link)return res.json({status:false,message:'- CadÃª o parÃ¢metro link?'})
if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
var islink = isUrl(link)
if (!islink) return res.json({ status : false, message : "[!] insira uma url vÃ¡lido"})  
let randomapibitly = apibitly[Math.floor(Math.random() * apibitly.length)]
const bitly = new BitlyClient(randomapibitly)
RegisKey(apikey, req);
bitly.shorten(link).then(function(result) {
res.json({status: true, criador: `@m4thxyz_`, result : result.link})
}).catch(function(error) {
 res.json({erro: "Erro no Servidor Interno"})
});
})

router.get('/api/linkshort/tinyurlwithalias', async (req, res, next) => {
var link = req.query.link
var alias = req.query.alias
var apikey = req.query.apikey;
if(!apikey)return res.json({status:false,message:'- CadÃª o parÃ¢metro apikey?'})
if(!alias)return res.json({status:false,message:'- CadÃª o parÃ¢metro alias?'})
if(!link)return res.json({status:false,message:'- CadÃª o parÃ¢metro link?'})
if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
var islink = isUrl(link)
if (!islink) return res.json({ status : false, message : "[!] insira parÃ¢metros de URL"})  
TinyURL.shortenWithAlias({url: link, alias: shortText(alias, 30)}).then(function(link)  {	
if (link == "Error") return res.json({erro: "Erro no Servidor Interno"})
RegisKey(apikey, req);
res.json({status: true, criador: `@m4thxyz_`, result: link})
})
})

router.get('/api/info/translate', async (req, res, next) => {
text = req.query.texto
ling = req.query.ling
apikey = req.query.apikey;
if (apikey === undefined) return res.status(404).send({status: 404, message: `insira o parÃ¢metro apikey`});
	if (!text ) return res.json({ status : false, message : "digite o parÃ¢metro de texto."})  
	if (!ling ) return res.json({ status : false, message : "parÃ¢metro de entrada: ling. VocÃª pode ver a lista de idiomas em https://cloud.google.com/translate/docs/languages"})  
if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
RegisKey(apikey, req);
defaultLang = 'en'
tld = 'pt'
let result
try {
result = await translate(`${text}`, {
tld,
to: ling,
})
} catch (e) {
result = await translate(`${text}`, {
tld,
to: defaultLang,
})
} finally {
res.json({
status: true,
result: result[0]
})}})

app.get('/api/editsvideo', async(req, res, next) => {
var { apikey, categoria } = req.query
if (!categoria) return res.json({ status : false,  message : "cade o parametro categoria"}) 
var EDT_ALEATORIOS = JSON.parse(fs.readFileSync("./base de dados/random/EDIT-ANIMES/ALEATORIOS.json").toString())
var EDT_BLEACH = JSON.parse(fs.readFileSync("./base de dados/random/EDIT-ANIMES/BLEACH.json").toString())
var EDT_CHAINSAW = JSON.parse(fs.readFileSync("./base de dados/random/EDIT-ANIMES/CHAINSAW.json").toString())
var EDT_DEMON_SLAYER = JSON.parse(fs.readFileSync("./base de dados/random/EDIT-ANIMES/DEMON_SLAYER.json").toString())
var EDT_DRAGONBALL = JSON.parse(fs.readFileSync("./base de dados/random/EDIT-ANIMES/DRAGONBALL.json").toString())
var EDT_HUNTER_X = JSON.parse(fs.readFileSync("./base de dados/random/EDIT-ANIMES/HUNTER_X.json").toString())
var EDT_JUJUTSU_KAISEN = JSON.parse(fs.readFileSync("./base de dados/random/EDIT-ANIMES/JUJUTSU_KAISEN.json").toString())
var EDT_NARUTO = JSON.parse(fs.readFileSync("./base de dados/random/EDIT-ANIMES/NARUTO.json").toString())
RST_CTRG = [
{NAME: "aleatorios", RANDOM: EDT_ALEATORIOS[Math.floor(Math.random() * EDT_ALEATORIOS.length)]}, 
{NAME: "bleach", RANDOM: EDT_BLEACH[Math.floor(Math.random() * EDT_BLEACH.length)]},
{NAME: "chainsaw", RANDOM: EDT_CHAINSAW[Math.floor(Math.random() * EDT_CHAINSAW.length)]},
{NAME: "demon_slayer", RANDOM: EDT_DEMON_SLAYER[Math.floor(Math.random() * EDT_DEMON_SLAYER.length)]},
{NAME: "dragonball", RANDOM: EDT_DRAGONBALL[Math.floor(Math.random() * EDT_DRAGONBALL.length)]},
{NAME: "hunters", RANDOM: EDT_HUNTER_X[Math.floor(Math.random() * EDT_HUNTER_X.length)]},
{NAME: "jujutsu_kaisen", RANDOM: EDT_JUJUTSU_KAISEN[Math.floor(Math.random() * EDT_JUJUTSU_KAISEN.length)]},
{NAME: "naruto", RANDOM: EDT_NARUTO[Math.floor(Math.random() * EDT_NARUTO.length)]}
]
var EDT = RST_CTRG.map(i => i.NAME).indexOf(categoria)
if(EDT < 0) return res.json({message: "categoria indisponÃ­vel."})
if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
RegisKey(apikey, req);
if(key.map(i => i.apikey)?.includes(apikey)){
await getBuffer(RST_CTRG[EDT].RANDOM).then(editRest => {
res.type('mp4')
res.send(editRest)
}).catch(e => {
res.json({status: false, resultado:'âŒï¸ Nenhuma resposta retornada ao servidor!ï¸'})
})
} else {
res.json({status: false, resultado:'â³ï¸ Tempo de resposta esgotado!'})
}
})

app.get('/api/dl/scdl', (req, res) => {
apikey = req.query.apikey
url = req.query.url
if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
if (!url) return res.json({ status : false,  message : "Cade o parametro url?"})
RegisKey(apikey, req);
soundl(url).then(async(e) => {
res.type('mp4')
res.send(await getBuffer(e.link_dl))
}).catch(e => {
res.json({erro: "Erro: "+e})
})
})

app.get('/api/dl/ytaudio', async (req, res, next) => {
apikey = req.query.apikey
url = req.query.url
if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
if (!url) return res.json({ status : false,  message : "Cade o parametro url?"})
RegisKey(apikey, req);
try {
const down = await youtubedl(url);
const audio = await down.audio['128kbps'].download();
data = await fetch(audio).then(v => v.buffer())
await fs.writeFileSync(bla+'/assets/playresulted.mp3', data)
res.sendFile(bla+'/assets/playresulted.mp3')
} catch (err) {
console.log(err)
};
});

app.get('/api/dl/ytvideo', async (req, res, next) => {
apikey = req.query.apikey
url = req.query.url
if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
if (!url) return res.json({ status : false,  message : "Cade o parametro url?"})
RegisKey(apikey, req);
try {
const down = await youtubedl(url);
const video = await down.video['360p'].download();
data = await fetch(video).then(v => v.buffer())
await fs.writeFileSync(bla+'/assets/playresulted.mp4', data)
res.sendFile(bla+'/assets/playresulted.mp4')
} catch (err) {
console.log(err)
};
});

app.get('/api/dl/ytaudio2', async (req, res, next) => {
apikey = req.query.apikey
url = req.query.url
if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
if (!url) return res.json({ status : false,  message : "Cade o parametro url?"})
RegisKey(apikey, req);
try {
const down = await youtubedl(url);
const audio = await down.audio['128kbps'].download();
data = await fetch(audio).then(v => v.buffer())
await fs.writeFileSync(bla+'/assets/playresultedplayresulted.mp3', data)
res.sendFile(bla+'/assets/playresultedplayresulted.mp3')
} catch (err) {
console.log(err)
};
});

app.get('/api/dl/ytvideo2', async (req, res, next) => {
apikey = req.query.apikey
url = req.query.url
if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
if (!url) return res.json({ status : false,  message : "Cade o parametro url?"})
RegisKey(apikey, req);
try {
const down = await youtubedl(url);
const video = await down.video['360p'].download();
data = await fetch(video).then(v => v.buffer())
await fs.writeFileSync(bla+'/assets/playresultedplayresulted.mp4', data)
res.sendFile(bla+'/assets/playresultedplayresulted.mp4')
} catch (err) {
console.log(err)
};
});

app.get('/api/myinstants', async(req, res, next) => {
apikey = req.query.apikey;
query = req.query.query
if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
if (!query) return res.json({ status : false,  message: "Coloque o parametro: query"})
RegisKey(apikey, req);
audioMeme.myinstants(query).then(data => {
res.json({resultado: data})
}).catch(e => {
res.json({status: 404, message: `Erro no Servidor Interno.`})
})
})

app.get('/api/tuna', async(req, res, next) => {
apikey = req.query.apikey;
query = req.query.query
if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
if (!query) return res.json({ status : false,  message: "Coloque o parametro: query"})
RegisKey(apikey, req);
audioMeme.tuna(query).then(data => {
res.json({resultado: data})
}).catch(e => {
res.json({status: 404, message: `Erro no Servidor Interno.`})
})
})

app.get('/api/dl/gdrive', async(req, res, next) => {
apikey = req.query.apikey;
url = req.query.url
if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
if (!url) return res.json({ status : false,  message: "Coloque o parametro: url"})
RegisKey(apikey, req);
GDriveDl(url).then(data => {
res.json({resultado: data})
}).catch(e => {
res.json({status: 404, message: `Erro no Servidor Interno.`})
})
})

app.get('/api/dl/mediafire', async(req, res, next) => {
apikey = req.query.apikey;
url = req.query.url
if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
if (!url) return res.json({ status : false,  message: "Coloque o parametro: url"})
RegisKey(apikey, req);
mediafiredl__(url).then(data => {
res.json({resultado: data})
}).catch(e => {
res.json({status: 404, message: `Erro no Servidor Interno.`})
})
})

app.get('/api/dl/mediafire2', async (req, res, next) => {
  apikey = req.query.apikey
  url = req.query.url
  if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
  if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
  if (!url) return res.json({ status : false,  message : "Cade o parametro url?"})
  RegisKey(apikey, req);
  mediafireDl(url)
  .then(data => {
  var resultado = data;
  res.json({
  resultado
  })
  }).catch(e => {
  res.json({erro:'Erro no Servidor Interno'})
  })
  })

app.get('/api/dl/mediafire3', async(req, res, next) => {
apikey = req.query.apikey
url = req.query.url
if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
if(!url) return res.json({ status : false,  message: "Coloque o parametro: url"})
RegisKey(apikey, req)
FongsiDev_Scraper.MediaFire(url).then(ABC => {
res.json({resultado: ABC.data})
}).catch(e => {
console.log(e)
res.json({erro: 404, message: `Erro no Servidor Interno.`})
})
})

app.get('/api/dl/igstory', async(req, res, next) => {
apikey = req.query.apikey;
usuario = req.query.usuario
if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
if (!usuario) return res.json({ status : false,  message: "cade o parametro usuario?"})
RegisKey(apikey, req);
instagramStoryUser(usuario).then(data => {
res.json({status: 200, resultado: data})
}).catch(e => {
res.json({status: 404, message: `Erro no Servidor Interno`})
})
})

app.get('/api/convert/image', async (req, res, next) => {
url = req.query.url
if(!url) return res.json({erro: "Faltando o parÃ¢metro url"})
apikey = req.query.apikey
if(!apikey) return res.json({erro: "Faltando o parÃ¢metro apikey"})
RegisKey(apikey, req);
try {
    hasil = url
	  data = await fetch(hasil).then(v => v.buffer())   
         await fs.writeFileSync(bla+'/assets/gostosinha.jpg', data)
        res.sendFile(bla+'/assets/gostosinha.jpg') 
} catch (error) {
return res.status(404).json({resultado: `Erro`, status: 500});
}
})

app.get('/api/igstalk', async(req, res, next) => {
apikey = req.query.apikey;
usuario = req.query.usuario
if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
if (!usuario) return res.json({ status : false,  message: "cade o parametro usuario?"})
RegisKey(apikey, req);
try {
ABC = await stalkig(usuario.replace("@", ""))
perfil = ABC.result.user_info
return res.json({criador: "@m4thxyz_", resultado: {
username: perfil.username,
fullname: perfil.full_name,
biography: perfil.biography,
externalurl: perfil.external_url,
is_private: perfil.is_private,
is_verified: perfil.is_verified,
posts: perfil.posts,
followers: perfil.followers,
following: perfil.following,
profile_photo: perfil.profile_pic_url,
stories: ABC?.result?.stories ? ABC?.result?.stories : [],
highlights: ABC?.result?.highlights ? ABC?.result?.highlights : []
}})
} catch(e) {
console.log(e)
return res.json({erro: "Erro no servidor interno..."})
}
})

app.get('/api/ttkstalk', async(req, res) => {
var { usuario, apikey } = req.query
if(!usuario) return res.json({status:false,message:'CadÃª o parÃ¢metro: usuario'})
if(!apikey) return res.json({status:false,message:'CadÃª o parÃ¢metro: apikey'})
if(!key.map(i => i.apikey)?.includes(apikey)) return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
RegisKey(apikey, req)
tiktokapidl.StalkUser(usuario.replace("@", "")).then(ABC => {
i = ABC.result
res.json({criador: "@m4thxyz_", resultado: {
username: i.users.username,
nickname: i.users.nickname,
avatar: i.users.avatarMedium,
biography: i.users.signature,
is_verified: i.users.verified,
is_private: i.users.privateAccount,
commerce_acc: i.users.commerceUser,
region: i.users.region,
followers: i.stats.followerCount,
following: i.stats.followingCount,
likes: i.stats.heartCount,
videos: i.stats.videoCount,
friends: i.stats.friendCount,
posts: i.stats.postCount
}})
}).catch(e => {
console.log(e)
res.json({resultado: `Erro`})
})
})

app.get('/api/aio', async(req, res, next) => {
apikey = req.query.apikey
url = req.query.url
if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
if(!url) return res.json({status: false,  message: "cade o parametro url?"})
RegisKey(apikey, req);
try {
ABC = await aio(url)
return res.json({criador: "@m4thxyz_", resultado: ABC.result})
} catch(e) {
console.log(e)
return res.json({erro: "Erro no servidor interno..."})
}
})

app.get('/api/dl/multidl', async(req, res, next) => {
apikey = req.query.apikey;
url = req.query.url
if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
if (!url) return res.json({ status : false,  message: "cade o parametro url?"})
RegisKey(apikey, req);
scraper.MultiDownload(url).then(data => {
res.json({status: 200, resultado: data})
}).catch(e => {
res.json({status: 404, message: `Erro no Servidor Interno`})
})
})

app.get('/api/search/imdb', async(req, res, next) => {
apikey = req.query.apikey;
query = req.query.query
if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
if (!query) return res.json({ status : false,  message: "cade o parametro query?"})
RegisKey(apikey, req);
scraper.IMDb.searchFilm(query).then(data => {
res.json({status: 200, resultado: data})
}).catch(e => {
res.json({status: 404, message: `Erro no Servidor Interno`})
})
})

app.get('/api/search/imdb_info', async(req, res, next) => {
apikey = req.query.apikey;
url = req.query.url
if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
if (!url) return res.json({ status : false,  message: "cade o parametro url?"})
RegisKey(apikey, req);
scraper.IMDb.infoFilm(url).then(data => {
res.json({status: 200, resultado: data})
}).catch(e => {
res.json({status: 404, message: `Erro no Servidor Interno`})
})
})

app.get('/api/rastreio', async(req, res, next) => {
var { apikey, code } = req.query;
if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
if(!code) return res.json({ status : false,  message: "faltando o parametro: code"})
RegisKey(apikey, req);
try {
rastrear = await rastrearEncomendas(code)
res.json({criador: `@m4thxyz_`, resultado: rastrear})
} catch(e) {
console.log(e)
res.json({criador: `@m4thxyz_`, resultado: `Erro`})
}
})

app.get('/api/pesquisa/pensador', async(req, res, next) => {
var { apikey, text } = req.query;
if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
if (!text) return res.json({ status : false,  message: "faltando o parametro: text"})
RegisKey(apikey, req);
pensador(text)
.then(response => {
res.json({status: 200, resultado: response});
}).catch(e => {
res.json({status: 404, message: `Erro no Servidor Interno.`})
})
})

app.get('/api/dl/spotify', async(req, res, next) => {
var { apikey, url } = req.query;
if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
if (!url) return res.json({ status : false,  message: "faltando o parametro: url"})
RegisKey(apikey, req);
try {
ABC = await fetchJson(`https://api.sabapi.tech/api/dl/spotify?url=${url}&apikey=matheuzinho2006`)
return res.json({criador: "@m4thxyz_", resultado: ABC.resultado})
} catch { res.json({erro: "Erro"}) }
})

app.get('/api/dl/capcut', async(req, res, next) => {
var { apikey, url } = req.query;
if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
if (!url) return res.json({ status : false,  message: "faltando o parametro: url"})
RegisKey(apikey, req);
scrapper.CapcutDL(url).then(response => {
res.json({status: 200, resultado: response});
}).catch(e => {
res.json({status: 404, message: `Erro no Servidor Interno.`})
})
})

app.get('/api/dl/threads', async(req, res, next) => {
var { apikey, url } = req.query;
if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
if (!url) return res.json({ status : false,  message: "faltando o parametro: url"})
RegisKey(apikey, req);
scrapper.ThreadsDL(url).then(response => {
res.json({status: 200, resultado: response});
}).catch(e => {
res.json({status: 404, message: `Erro no Servidor Interno.`})
})
})

app.get('/api/dl/twitter', async(req, res, next) => {
var { apikey, url } = req.query;
if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
if (!url) return res.json({ status : false,  message: "faltando o parametro: url"})
RegisKey(apikey, req);
scrapper.TwitterDL(url).then(response => {
res.json({status: 200, resultado: response});
}).catch(e => {
res.json({status: 404, message: `Erro no Servidor Interno.`})
})
})

app.get('/api/spotifysearch', async(req, res, next) => {
var { apikey, query } = req.query
if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
if(!query) return res.json({ status : false,  message: "faltando o parametro: query"})
RegisKey(apikey, req);
try {
ABC = await spotify(query)
return res.json({criador: "@m4thxyz_", resultado: ABC})
} catch(e) { console.log(e)
res.json({erro: "Erro"}) }
})

app.get('/vip/check-number', async (req, res) => {
query = req.query.query
if(!query) return res.json({status:false, resultado:'Cade o parametro query??'})
var apikey = req.query.apikey
if(!apikey) return res.json({resultado:'Cade o parametro apikey?'})
if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.consulta == false) return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
RegisKey(apikey, req);
try {
anu = await fetchJson(`http://apilayer.net/api/validate?access_key=d57f91cf25db296a9e223888cfdc064a&number=${query}`)
res.json({
status: true, 
criador: `@m4thxyz_`,
resultado: {
number: anu.number, 
local_format: anu.local_format ,
international_format: anu.international_format,
country_prefix: anu.country_prefix,
country_code: anu.country_code,
country_name: anu.country_name, 
location: anu.location,
carrier: anu.carrier,
line_type: anu.line_type, 
}
})
} catch (error) {
return res.status(404).json({ resultado: `[â—] Nenhuma resposta obtida... Favor, tente mais tarde ğŸ’¢`, status: 500 });
}
})

app.get('/vip/gerar-cc', async (req, res) => {
var apikey = req.query.apikey
if(!apikey) return res.json({resultado:'Cade o parametro apikey?'})
if(!key.map(i => i.apikey)?.includes(apikey))return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.consulta == false) return res.sendFile(path.join(__dirname, "./public/", "apikey_invalida.html"))
if(key[key.map(i => i?.apikey)?.indexOf(apikey)]?.request <= 0) return res.json({message: "Apikey invÃ¡lida ou requests esgotados!"})
RegisKey(apikey, req);
try {
ABC = await fetchJson(`https://api.lolhuman.xyz/api/vccgenerator?apikey=GataDios&bin=${Math.floor(Math.random()*999899) + 100}`)
res.json({
status: true,
criador: `@m4thxyz_`,
resultado: ABC.result || []
})
} catch (error) {
return res.status(404).json({ resultado: `[â—] Nenhuma resposta obtida... Favor, tente mais tarde ğŸ’¢`, status: 500 });
}
})

//////MOSTRA SE O APP FOI ABERTO
app.listen(PORT, () => {

const bannerst = cfonts.render((`BLACK API`), {
  font: 'block',
  align: "center",
  gradient: ['yellow', 'red']
});

const bannerst2 = cfonts.render((`matheuzinho | @m4thxyz_`), {
font: 'console',
align: 'center',
gradient: ['cyan', 'blue']
});

console.log(bannerst.string)
console.log(bannerst2.string)
console.log(colors.cyan('REST-API ligada com sucesso na porta: ') + PORT)
})

module.exports = router;
